<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Wu Chuan Blogs</title>
		<link>https://wuchuan.monster/posts/</link>
		<description>Recent content in Posts on Wu Chuan Blogs</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>zn-cn</language>
		<copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
		<lastBuildDate>Tue, 11 Feb 2020 14:12:19 +0800</lastBuildDate>
		<atom:link href="https://wuchuan.monster/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Vue 中的 .sync 修饰符</title>
			<link>https://wuchuan.monster/posts/sync/</link>
			<pubDate>Tue, 11 Feb 2020 14:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/sync/</guid>
			<description>.sync 修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。 示例代码如下：
&amp;lt;comp :foo.sync=&amp;#34;bar&amp;#34;&amp;gt;&amp;lt;/comp&amp;gt;会被扩展为：
&amp;lt;comp :foo=&amp;#34;bar&amp;#34; @update:foo=&amp;#34;val =&amp;gt; bar = val&amp;#34;&amp;gt;&amp;lt;/comp&amp;gt;当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：
this.$emit(&amp;#39;update:foo&amp;#39;, newValue)猛一看不明白，下边我么通过一个实例（弹窗的关闭事件）来说明这个代码到底是怎么运用的。
&amp;lt;template&amp;gt;&amp;lt;div class=&amp;#34;details&amp;#34;&amp;gt;&amp;lt;myComponent :show.sync=&amp;#39;valueChild&amp;#39; style=&amp;#34;padding: 30px 20px 30px 5px;border:1px solid #ddd;margin-bottom: 10px;&amp;#34;&amp;gt;&amp;lt;/myComponent&amp;gt;&amp;lt;button @click=&amp;#34;changeValue&amp;#34;&amp;gt;toggle&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/template&amp;gt;&amp;lt;script&amp;gt;import Vue from &amp;#39;vue&amp;#39;Vue.component(&amp;#39;myComponent&amp;#39;, {template: `&amp;lt;div v-if=&amp;#34;show&amp;#34;&amp;gt;&amp;lt;p&amp;gt;默认初始值是{{show}}，所以是显示的&amp;lt;/p&amp;gt;&amp;lt;button @click.stop=&amp;#34;closeDiv&amp;#34;&amp;gt;关闭&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;`,props:[&amp;#39;show&amp;#39;],methods: {closeDiv() {this.$emit(&amp;#39;update:show&amp;#39;, false); //触发 input 事件，并传入新值 }}})export default{data(){return{valueChild:true,}},methods:{changeValue(){this.</description>
			<content type="html"><![CDATA[<p>.sync 修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。
示例代码如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-vue" data-lang="vue"><span class="p">&lt;</span><span class="nt">comp</span> <span class="nt">:foo.sync</span><span class="s">=&#34;bar&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">comp</span><span class="p">&gt;</span>
</code></pre></div><p>会被扩展为：</p>
<div class="highlight"><pre class="chroma"><code class="language-vue" data-lang="vue"><span class="p">&lt;</span><span class="nt">comp</span> <span class="nt">:foo</span><span class="s">=&#34;bar&#34;</span> <span class="err">@</span><span class="na">update</span><span class="o">:</span><span class="na">foo</span><span class="o">=</span><span class="s">&#34;val =&gt; bar = val&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">comp</span><span class="p">&gt;</span>
</code></pre></div><p>当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：</p>
<div class="highlight"><pre class="chroma"><code class="language-vue" data-lang="vue"><span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;update:foo&#39;</span><span class="p">,</span> <span class="nx">newValue</span><span class="p">)</span>
</code></pre></div><p>猛一看不明白，下边我么通过一个实例（弹窗的关闭事件）来说明这个代码到底是怎么运用的。</p>
<div class="highlight"><pre class="chroma"><code class="language-vue" data-lang="vue"><span class="p">&lt;</span><span class="nt">template</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;details&#34;</span><span class="p"></span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">myComponent</span> <span class="o">:</span><span class="na">show.sync</span><span class="err">=</span><span class="err">&#39;</span><span class="na">valueChild</span><span class="err">&#39;</span> <span class="na">style</span><span class="o">=</span><span class="s">&#34;padding: 30px 20px 30px 5px;border:1px solid #ddd;margin-bottom: 10px;&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">myComponent</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="nt">@click</span><span class="s">=&#34;changeValue&#34;</span><span class="p">&gt;</span><span class="na">toggle</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">template</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p"></span><span class="p">&gt;</span>
<span class="kr">import</span> <span class="nx">Vue</span> <span class="nx">from</span> <span class="s1">&#39;vue&#39;</span>
<span class="nx">Vue</span><span class="p">.</span><span class="nx">component</span><span class="p">(</span><span class="s1">&#39;myComponent&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="nx">template</span><span class="o">:</span> <span class="sb">`</span><span class="sb">&lt;div v-if=&#34;show&#34;&gt;
</span><span class="sb">                    &lt;p&gt;默认初始值是{{show}}，所以是显示的&lt;/p&gt;
</span><span class="sb">                    &lt;button @click.stop=&#34;closeDiv&#34;&gt;关闭&lt;/button&gt;
</span><span class="sb">                 &lt;/div&gt;</span><span class="sb">`</span><span class="p">,</span>
      <span class="nx">props</span><span class="o">:</span><span class="p">[</span><span class="s1">&#39;show&#39;</span><span class="p">]</span><span class="p">,</span>
      <span class="nx">methods</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">closeDiv</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="s1">&#39;update:show&#39;</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span><span class="p">;</span> <span class="c1">//触发 input 事件，并传入新值
</span><span class="c1"></span>        <span class="p">}</span>
      <span class="p">}</span>
<span class="p">}</span><span class="p">)</span>
<span class="kr">export</span> <span class="k">default</span><span class="p">{</span>
    <span class="nx">data</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
        <span class="k">return</span><span class="p">{</span>
            <span class="nx">valueChild</span><span class="o">:</span><span class="kc">true</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span><span class="p">,</span>
    <span class="nx">methods</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">changeValue</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">valueChild</span> <span class="o">=</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">valueChild</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">script</span><span class="p">&gt;</span>
</code></pre></div><p>动态效果如下：</p>
<p><img src="/images/sync.gif" alt="Image"></p>
<p>vue 修饰符sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。如果我们不用.sync，我们想做上面的那个弹窗功能，我们也可以props传初始值，然后事件监听，实现起来也不算复杂。这里用sync实现，只是给大家提供一个思路，让其明白他的实现原理，可能有其它复杂的功能适用sync。</p>
]]></content>
		</item>
		
		<item>
			<title>Vue安装</title>
			<link>https://wuchuan.monster/posts/vue%E5%AE%89%E8%A3%85/</link>
			<pubDate>Wed, 05 Feb 2020 14:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/vue%E5%AE%89%E8%A3%85/</guid>
			<description> 安装@vue/cli  npm install -g @vue/cli# ORyarn global add @vue/cli //推荐 创建目录：vue create 路径（路径可用.点）
  选择使用配置(如下图)   进入目录，运行yarn serve开启webpack-dev-server（npm run serve）
  两个版本对应的文件名 完整版对应文件名：从CDN引入vue.js;vue.min.js;
非完整版对应文件名:vue.runtime.js;vue.runtime.min.js;
template 和 render 怎么用 Vue template的使用方法：直接写在页面上或者JS上
&amp;lt;template&amp;gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt; {{n}}&amp;lt;button @click=&amp;quot;add&amp;quot;&amp;gt;+1&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt;Vue render的使用方法
render函数接收一个参数h，这个参数是vue传的；用这个参数去创建实例
render(h){ return h(&#39;div&#39;, [this.n,h(&#39;{on:{click:this.add}’,&#39;+1&#39;])}如何用 codesandbox.io 写 Vue 代码  codesandbox.io 选择Vue,create sanbox 创建沙盒 exprot zip 导出文件 Browser 选项会提供一个链接预览  </description>
			<content type="html"><![CDATA[<ol>
<li>安装@vue/cli</li>
</ol>
<pre><code>npm install -g @vue/cli
# OR
yarn global add @vue/cli   //推荐
</code></pre><ol start="2">
<li>
<p>创建目录：vue create 路径（路径可用.点）</p>
</li>
<li>
<p>选择使用配置(如下图)
<img src="/images/Vue%E9%85%8D%E7%BD%AE1.jpg" alt="image">
<img src="/images/Vue%E9%85%8D%E7%BD%AE2.jpg" alt="image"></p>
</li>
<li>
<p>进入目录，运行yarn serve开启webpack-dev-server（npm run serve）</p>
</li>
</ol>
<h3 id="heading">两个版本对应的文件名</h3>
<p>完整版对应文件名：从CDN引入vue.js;vue.min.js;</p>
<p>非完整版对应文件名:vue.runtime.js;vue.runtime.min.js;</p>
<h3 id="template--render-">template 和 render 怎么用</h3>
<p>Vue template的使用方法：直接写在页面上或者JS上</p>
<pre><code>&lt;template&gt;
    &lt;div id=&quot;app&quot;&gt;      
        {{n}}
        &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt;   
   &lt;/div&gt; 
&lt;/template&gt;
</code></pre><p>Vue render的使用方法</p>
<p>render函数接收一个参数h，这个参数是vue传的；用这个参数去创建实例</p>
<pre><code>render(h){ 
     return h('div', [this.n,h('{on:{click:this.add}’,'+1'])
 }
</code></pre><h3 id="-codesandboxio--vue-">如何用 codesandbox.io 写 Vue 代码</h3>
<ul>
<li>codesandbox.io</li>
<li>选择Vue,create sanbox 创建沙盒</li>
<li>exprot zip 导出文件</li>
<li>Browser 选项会提供一个链接预览</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>浅析MVC</title>
			<link>https://wuchuan.monster/posts/mvc%E5%B0%8F%E7%BB%93/</link>
			<pubDate>Wed, 05 Feb 2020 10:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/mvc%E5%B0%8F%E7%BB%93/</guid>
			<description>MVC 三个对象分别做什么，给出伪代码示例 MVC包括三个对象，分别是M、V、C M-Model(数据模型) 负责操作所有数据 V-View(视图)负责所有UI界面 C-Controller(控制器)负责其他
MVC伪代码 const m = {//数据层，关于数据的操作放在这里 data:{n:parseInt(localStorage.getItem(&amp;#39;number&amp;#39;)||100)},//数据初始化 update:function (data) {//更新数据的方法 },delete:function (data) {//删除数据的方法 },get:function (data) {//获得数据的方法 }}const v = {//视图层，关于视图的操作放在这里 el:&amp;#39;挂载点&amp;#39;,html:&amp;#39;需要插入元素内的HTML内容&amp;#39;,render(&amp;#39;渲染html&amp;#39;)}const c = {//控制层，关于事件监听的放到这里 //找到重要的元素绑定事件 //如果触发事件调用更改数据方法及渲染方法 const a =$(&amp;#39;找到A&amp;#39;)const b = $(&amp;#39;找到B&amp;#39;)b.on(&amp;#39;click&amp;#39;,function(){//调用数据层方法更改数据 //调用视图层方法渲染页面 })}EventBus 有哪些 API，是做什么用的，给出伪代码示例 eventbus也是一种设计模式或者框架，主要用于组件/对象间通信的优化简化</description>
			<content type="html"><![CDATA[<h3 id="mvc-">MVC 三个对象分别做什么，给出伪代码示例</h3>
<p>MVC包括三个对象，分别是M、V、C
M-Model(数据模型) 负责操作所有数据
V-View(视图)负责所有UI界面
C-Controller(控制器)负责其他</p>
<h3 id="mvc">MVC伪代码</h3>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">m</span> <span class="o">=</span> <span class="p">{</span><span class="c1">//数据层，关于数据的操作放在这里
</span><span class="c1"></span>    <span class="nx">data</span><span class="o">:</span><span class="p">{</span>
        <span class="nx">n</span><span class="o">:</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">localStorage</span><span class="p">.</span><span class="nx">getItem</span><span class="p">(</span><span class="s1">&#39;number&#39;</span><span class="p">)</span><span class="o">||</span><span class="mi">100</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span><span class="c1">//数据初始化
</span><span class="c1"></span>    <span class="nx">update</span><span class="o">:</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//更新数据的方法
</span><span class="c1"></span>    <span class="p">}</span><span class="p">,</span>
    <span class="k">delete</span><span class="o">:</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//删除数据的方法
</span><span class="c1"></span>    <span class="p">}</span><span class="p">,</span>
    <span class="nx">get</span><span class="o">:</span><span class="kd">function</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//获得数据的方法
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">v</span> <span class="o">=</span> <span class="p">{</span><span class="c1">//视图层，关于视图的操作放在这里
</span><span class="c1"></span>    <span class="nx">el</span><span class="o">:</span><span class="s1">&#39;挂载点&#39;</span><span class="p">,</span>
    <span class="nx">html</span><span class="o">:</span><span class="s1">&#39;需要插入元素内的HTML内容&#39;</span><span class="p">,</span>
    <span class="nx">render</span><span class="p">(</span><span class="s1">&#39;渲染html&#39;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span><span class="c1">//控制层，关于事件监听的放到这里
</span><span class="c1"></span>    <span class="c1">//找到重要的元素绑定事件
</span><span class="c1"></span>    <span class="c1">//如果触发事件调用更改数据方法及渲染方法
</span><span class="c1"></span>    <span class="kr">const</span> <span class="nx">a</span> <span class="o">=</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;找到A&#39;</span><span class="p">)</span>
    <span class="kr">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="s1">&#39;找到B&#39;</span><span class="p">)</span>
    <span class="nx">b</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="p">)</span><span class="p">{</span>
        <span class="c1">//调用数据层方法更改数据
</span><span class="c1"></span>        <span class="c1">//调用视图层方法渲染页面
</span><span class="c1"></span>    <span class="p">}</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div><h3 id="eventbus--api">EventBus 有哪些 API，是做什么用的，给出伪代码示例</h3>
<p>eventbus也是一种设计模式或者框架，主要用于组件/对象间通信的优化简化</p>
<p>eventbus包含很多方法，on方法可以监听事件，trigger方法可以触发事件，off卸载监听。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="c1">//伪代码
</span><span class="c1"></span><span class="kr">import</span> <span class="nx">$</span> <span class="nx">from</span> <span class="s1">&#39;jquery&#39;</span>
<span class="kr">const</span> <span class="nx">eventbus</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nb">window</span><span class="p">)</span><span class="c1">//返回一个eventbus的所有方法的对象
</span><span class="c1"></span>
<span class="kr">const</span> <span class="nx">model</span> <span class="o">=</span> <span class="p">{</span><span class="c1">//数据层
</span><span class="c1"></span>    <span class="nx">data</span><span class="o">:</span><span class="p">{</span><span class="s1">&#39;数据&#39;</span><span class="o">:</span><span class="mi">1</span><span class="p">}</span><span class="p">,</span>
    <span class="nx">update</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="p">{</span>
        <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">model</span><span class="p">.</span><span class="nx">data</span><span class="p">,</span><span class="nx">data</span><span class="p">)</span><span class="c1">//更新数据
</span><span class="c1"></span>        <span class="nx">eventbus</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span><span class="s1">&#39;更新数据&#39;</span><span class="p">)</span><span class="c1">//触发事件 
</span><span class="c1"></span>    <span class="p">}</span>
    
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">View</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">el</span><span class="o">:</span><span class="s1">&#39;挂载点&#39;</span><span class="err">，</span>
    <span class="nx">html</span><span class="o">:</span><span class="s1">&#39;&lt;div&gt;{{内容}}&lt;/div&gt;&#39;</span><span class="p">,</span>
    <span class="nx">init</span><span class="p">(</span><span class="nx">container</span><span class="p">)</span><span class="p">{</span>
        <span class="nx">View</span><span class="p">.</span><span class="nx">el</span> <span class="o">=</span> <span class="nx">$</span><span class="p">(</span><span class="nx">container</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">render</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span><span class="p">{</span>
        <span class="nx">$</span><span class="p">(</span><span class="nx">View</span><span class="p">.</span><span class="nx">html</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;{{n}}&#39;</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span><span class="p">)</span>
        <span class="p">.</span><span class="nx">appendTo</span><span class="p">(</span><span class="nx">View</span><span class="p">.</span><span class="nx">el</span><span class="p">)</span><span class="c1">//更换新的内容渲染进页面
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">control</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">init</span><span class="p">(</span><span class="nx">container</span><span class="p">)</span><span class="p">{</span>
        <span class="nx">View</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">container</span><span class="p">)</span>
        <span class="nx">View</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span><span class="c1">//初始化页面
</span><span class="c1"></span>        <span class="nx">autoBindEvents</span><span class="p">(</span><span class="p">)</span>
        <span class="nx">eventbus</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;更新数据&#39;</span><span class="p">,</span><span class="p">(</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span><span class="c1">//监听数据层的eventbus.trigger如果有被触发说明数据有更新从而进行渲染
</span><span class="c1"></span>            <span class="nx">View</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">n</span><span class="p">)</span>
        <span class="p">}</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span>
    
    <span class="nx">add</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="p">{</span><span class="nx">n</span><span class="o">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span><span class="c1">//改变数据方法
</span><span class="c1"></span>    <span class="nx">minus</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">m</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="p">{</span><span class="nx">n</span><span class="o">:</span> <span class="nx">m</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">}</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span><span class="c1">//改变数据
</span><span class="c1"></span>    <span class="c1">//监听改变数据的按钮
</span><span class="c1"></span>    <span class="nx">autoBindEvents</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">View</span><span class="p">.</span><span class="nx">el</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span><span class="s1">&#39;app1&#39;</span><span class="p">,</span><span class="s1">&#39;add&#39;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//当然当需求更复杂的时候我们可以将eventbus写成一个类，让生成的实例对象继承eventbus，这样每个对象都拥有了可以触发和监听的功能，相当灵活
</span><span class="c1"></span>
</code></pre></div><h3 id="heading">表驱动编程是做什么的（可以自己查查资料）</h3>
<p>定义:表驱动编程是一种使我们可以再表中查找信息，而不必写很多逻辑语句（if或case）来把它们找出来的方法，事实上，任何信息都可以通过表来挑选，再简单情况下用逻辑语句是更简单的，但是一旦需要判断条件增多那我们可能要写大量重复的判断语句，这时候我们适当的用表中提取出的值来写条件判断将事半功倍。</p>
<h3 id="heading-1">我是如何理解模块化的</h3>
<ul>
<li>避免命名冲突(减少命名空间污染)</li>
<li>更好的分离, 按需加载</li>
<li>更高复用性</li>
<li>高可维护性</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>VScode使用VIM小结</title>
			<link>https://wuchuan.monster/posts/vscode%E4%B8%8Evim/</link>
			<pubDate>Tue, 14 Jan 2020 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/vscode%E4%B8%8Evim/</guid>
			<description>移动类（motion） h（左）、l（右）、j（上）、k（下）、f（front）、b（back）、u（up）
编辑类（operator） d（delete）、i（insert）、a（append）、c（change）、y（copy）、p（paste）
多行编辑添加一样的内容  CTRL+v 然后 a/A 或者 i/I 插入内容  复制、剪切、粘贴(普通模式、可视模式)  复制：yy/Y 复制一行 剪切：dd/D 剪切或删除一行 粘贴：p/P 粘贴（粘贴的地方不同)  其他  w 光标到单词末尾 b 光标到单词开头 x 删除一个字符 r/R 替换一个字符/替换模式 $ 到行尾 ^ 到行头 gg 到文本开头 G 到文本末尾 u 撤消最后一次修改 o 在当前行的下边插入新行 O 在当前行的上边插入新行 50% 移动到文本中间（数字可改） I 到首行插入 A 在当前行插入文本  </description>
			<content type="html"><![CDATA[<h3 id="motion">移动类（motion）</h3>
<p>h（左）、l（右）、j（上）、k（下）、f（front）、b（back）、u（up）</p>
<h3 id="operator">编辑类（operator）</h3>
<p>d（delete）、i（insert）、a（append）、c（change）、y（copy）、p（paste）</p>
<h3 id="heading">多行编辑添加一样的内容</h3>
<ol>
<li>CTRL+v</li>
<li>然后 a/A 或者 i/I 插入内容</li>
</ol>
<h3 id="heading-1">复制、剪切、粘贴(普通模式、可视模式)</h3>
<ul>
<li>复制：yy/Y 复制一行</li>
<li>剪切：dd/D 剪切或删除一行</li>
<li>粘贴：p/P 粘贴（粘贴的地方不同)</li>
</ul>
<h3 id="heading-2">其他</h3>
<ul>
<li>w  光标到单词末尾</li>
<li>b  光标到单词开头</li>
<li>x  删除一个字符</li>
<li>r/R 替换一个字符/替换模式</li>
<li>$  到行尾</li>
<li>^  到行头</li>
<li>gg 到文本开头</li>
<li>G  到文本末尾</li>
<li>u  撤消最后一次修改</li>
<li>o   在当前行的下边插入新行</li>
<li>O   在当前行的上边插入新行</li>
<li>50% 移动到文本中间（数字可改）</li>
<li>I 到首行插入</li>
<li>A 在当前行插入文本</li>
</ul>
<p><img src="/images/vim%E9%94%AE%E4%BD%8D%E5%9B%BE.gif" alt="键位图"></p>
]]></content>
		</item>
		
		<item>
			<title>flex布局</title>
			<link>https://wuchuan.monster/posts/flexgrid%E5%B8%83%E5%B1%80/</link>
			<pubDate>Mon, 13 Jan 2020 10:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/flexgrid%E5%B8%83%E5%B1%80/</guid>
			<description>flex container属性:
.container{display:flex;}把容器定义为flex； flex-direction:
.container{flex-direction:row|row-reverse |column|column-reverse;} row（默认值）：从左到右ltr；从右到左rtl row-reverse：从右到左ltr; 从左到右rtl column：与row上至下相同 column-reverse：与row-reverse下至上相同  flex-wrap
.container{flex-wrap:nowrap | wrap | wrap-reverse;} nowrap （默认）：所有弹性项目都在一行上 wrap：弹性项目将从上到下缠绕在多行上。 wrap-reverse：弹性项目将从下到上缠绕在多行上。 flex-flow: 这是flex-direction和flex-wrap属性的简写，它们一起定义了伸缩容器的主轴和交叉轴。默认值为row nowrap。  flex-flow:&amp;lt;&amp;#39;flex-direction&amp;#39;&amp;gt;||&amp;lt;&amp;#39;flex-wrap&amp;#39;&amp;gt;主轴对齐方式： flex-content
.container {justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;} flex-start （默认）：物品被包装在弹性方向的开始处。 flex-end：项目在伸缩方向的末端打包。 start：物品被包装到方向的起点writing-mode。 end：物品朝着方向的末端包装writing-mode。 left：项目朝着容器的左边缘包装，除非对而言没有意义flex-direction，则其行为类似于start。 right：物品会朝着容器的右边缘包装，除非对而言没有意义flex-direction，则其行为类似于start。 center：项目沿线居中 space-between：项目在行中均匀分布；第一项位于开始行，最后一项位于结束行 space-around：项目在行中均匀分布，并且周围有相等的空间。请注意，从视觉上看，空间是不相等的，因为所有项目的两侧都具有相等的空间。第一项相对于容器边缘有一个单位的空间，但是下一项之间有两个单位的空间，因为下一项具有自己的适用间距。 space-evenly：分配项目，以使任意两个项目之间的间距（以及到边缘的间距）相等。 次轴对齐方式:  align-items</description>
			<content type="html"><![CDATA[<p><strong>flex container属性:</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span><span class="p">{</span>
    <span class="k">display</span><span class="p">:</span><span class="kc">flex</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>把容器定义为flex；
<strong>flex-direction:</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span><span class="p">{</span>
    <span class="k">flex-direction</span><span class="p">:</span><span class="kc">row</span><span class="o">|</span><span class="kc">row</span><span class="o">-</span><span class="kc">reverse</span> <span class="o">|</span><span class="kc">column</span><span class="o">|</span><span class="kc">column</span><span class="o">-</span><span class="kc">reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>row（默认值）：从左到右ltr；从右到左rtl</li>
<li>row-reverse：从右到左ltr; 从左到右rtl</li>
<li>column：与row上至下相同</li>
<li>column-reverse：与row-reverse下至上相同</li>
</ul>
<p><strong>flex-wrap</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span><span class="p">{</span>
    <span class="k">flex-wrap</span><span class="p">:</span><span class="kc">nowrap</span> <span class="o">|</span> <span class="kc">wrap</span> <span class="o">|</span> <span class="kc">wrap</span><span class="o">-</span><span class="kc">reverse</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>nowrap （默认）：所有弹性项目都在一行上</li>
<li>wrap：弹性项目将从上到下缠绕在多行上。</li>
<li>wrap-reverse：弹性项目将从下到上缠绕在多行上。</li>
<li>flex-flow:
这是flex-direction和flex-wrap属性的简写，它们一起定义了伸缩容器的主轴和交叉轴。默认值为row nowrap。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="nt">flex-flow</span><span class="o">:</span><span class="o">&lt;</span><span class="s1">&#39;flex-direction&#39;</span><span class="o">&gt;</span><span class="o">|</span><span class="o">|</span><span class="o">&lt;</span><span class="s1">&#39;flex-wrap&#39;</span><span class="o">&gt;</span>
</code></pre></div><p>主轴对齐方式：
<strong>flex-content</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span> <span class="p">{</span>
  <span class="k">justify-content</span><span class="p">:</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">start</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">end</span> <span class="o">|</span> <span class="kc">center</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">between</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">around</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">evenly</span> <span class="o">|</span> <span class="kc">start</span> <span class="o">|</span> <span class="kc">end</span> <span class="o">|</span> <span class="kc">left</span> <span class="o">|</span> <span class="kc">right</span> <span class="o">...</span> <span class="o">+</span> <span class="n">safe</span> <span class="o">|</span> <span class="n">unsafe</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>flex-start （默认）：物品被包装在弹性方向的开始处。</li>
<li>flex-end：项目在伸缩方向的末端打包。</li>
<li>start：物品被包装到方向的起点writing-mode。</li>
<li>end：物品朝着方向的末端包装writing-mode。</li>
<li>left：项目朝着容器的左边缘包装，除非对而言没有意义flex-direction，则其行为类似于start。</li>
<li>right：物品会朝着容器的右边缘包装，除非对而言没有意义flex-direction，则其行为类似于start。</li>
<li>center：项目沿线居中</li>
<li>space-between：项目在行中均匀分布；第一项位于开始行，最后一项位于结束行</li>
<li>space-around：项目在行中均匀分布，并且周围有相等的空间。请注意，从视觉上看，空间是不相等的，因为所有项目的两侧都具有相等的空间。第一项相对于容器边缘有一个单位的空间，但是下一项之间有两个单位的空间，因为下一项具有自己的适用间距。</li>
<li>space-evenly：分配项目，以使任意两个项目之间的间距（以及到边缘的间距）相等。
次轴对齐方式:</li>
</ul>
<p><strong>align-items</strong></p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span> <span class="p">{</span>
  <span class="k">align-items</span><span class="p">:</span> <span class="kc">stretch</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">start</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">end</span> <span class="o">|</span> <span class="kc">center</span> <span class="o">|</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">first</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">last</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">start</span> <span class="o">|</span> <span class="kc">end</span> <span class="o">|</span> <span class="n">self-start</span> <span class="o">|</span> <span class="n">self-end</span> <span class="o">+</span> <span class="o">...</span> <span class="n">safe</span> <span class="o">|</span> <span class="n">unsafe</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>stretch （默认）：拉伸以填充容器（仍然遵守最小宽度/最大宽度）</li>
<li>flex-start/ start/ self-start：项目放置在十字轴的起点。它们之间的区别是微妙的，并且是关于flex-direction遵守规则或writing-mode规则的。</li>
<li>flex-end/ end/ self-end：项目放置在十字轴的末端。差异再次是微妙的，涉及尊重flex-direction规则与writing-mode规则。</li>
<li>center：项目在横轴上居中</li>
<li>baseline：项目对齐，例如基线对齐</li>
<li>在safe和unsafe修改关键字，可以结合使用这些关键字的所有的休息（但是注意浏览器支持），及处理帮助您防止对位元件，使得内容变得不可访问。</li>
</ul>
<p>多行对齐(用的较少):</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">container</span> <span class="p">{</span>
  <span class="k">align-content</span><span class="p">:</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">start</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">end</span> <span class="o">|</span> <span class="kc">center</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">between</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">around</span> <span class="o">|</span> <span class="kc">space</span><span class="o">-</span><span class="n">evenly</span> <span class="o">|</span> <span class="kc">stretch</span> <span class="o">|</span> <span class="kc">start</span> <span class="o">|</span> <span class="kc">end</span> <span class="o">|</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">first</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">last</span> <span class="kc">baseline</span> <span class="o">+</span> <span class="o">...</span> <span class="n">safe</span> <span class="o">|</span> <span class="n">unsafe</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><ul>
<li>flex-start/ start：包装到容器开头的项目。（受更多支持）flex-start兑现，flex-direction而start兑现writing-mode方向。</li>
<li>flex-end/ end：包装在容器末端的物品。（更多的支持）flex-end兑现，flex-direction而末端则兑现writing-mode方向。</li>
<li>center：位于容器中心的项目</li>
<li>space-between：物品平均分配；第一行在容器的开头，而最后一行在容器的结尾</li>
<li>space-around：项目均匀分布在每行周围</li>
<li>space-evenly：项目均匀分布，周围有相等的空间</li>
<li>stretch （默认）：线拉伸以占据剩余空间</li>
</ul>
<p>flex item属性:</p>
<p>默认情况下，弹性项目按源顺序排列。但是，该order属性控制它们在flex容器中出现的顺序。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">order</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">integer</span><span class="o">&gt;</span><span class="p">;</span> <span class="c">/* default is 0 */</span>
<span class="p">}</span>
</code></pre></div><p>这定义了弹性项目在必要时增长的能力。它接受作为比例的无单位值。它决定了项目应在伸缩容器内部占用多少可用空间。</p>
<p>弹性成长,负数无效。</p>
<p>如果所有项目都flex-grow设置为1，则容器中的剩余空间将平均分配给所有子项。</p>
<p>如果其中一个孩子的值为2，则剩余空间将占其他孩子的两倍（或者至少会尝试）。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">flex-grow</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">number</span><span class="o">&gt;</span><span class="p">;</span> <span class="c">/* default 0 */</span>
<span class="p">}</span>
</code></pre></div><p>弯曲收缩:</p>
<p>这定义了弹性项目在必要时收缩的能力。负数无效。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">flex-shrink</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">number</span><span class="o">&gt;</span><span class="p">;</span> <span class="c">/* default 1 */</span>
<span class="p">}</span>
</code></pre></div><p>flex-basis:
这定义了剩余空间分配之前元素的默认大小。 它可以是长度（例如20％，5rem等）或关键字。 auto关键字的意思是“看看我的width或height属性”（由main-size关键字临时完成，直到弃用）。 content关键字的意思是“根据项目的内容调整大小”-此关键字尚未得到很好的支持，因此很难测试，也很难知道其弟兄的max-content，min-content和fit-content。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">flex-basis</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">length</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">auto</span><span class="p">;</span> <span class="c">/* default auto */</span>
<span class="p">}</span>
</code></pre></div><p>flex:</p>
<p>这是简写flex-grow, flex-shrink和flex-basis合并。第二和第三个参数（flex-shrink和flex-basis）是可选的。默认值为0 1 auto。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">flex</span><span class="p">:</span> <span class="kc">none</span> <span class="o">|</span> <span class="p">[</span> <span class="o">&lt;</span><span class="s1">&#39;flex-grow&#39;</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="s1">&#39;flex-shrink&#39;</span><span class="o">&gt;?</span> <span class="o">||</span> <span class="o">&lt;</span><span class="s1">&#39;flex-basis&#39;</span><span class="o">&gt;</span> <span class="p">]</span>
<span class="p">}</span>
</code></pre></div><p><strong>align-items:</strong>
这允许align-items为单个弹性项目覆盖默认对齐方式（或由指定的对齐方式）。</p>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="p">.</span><span class="nc">item</span> <span class="p">{</span>
  <span class="k">align-self</span><span class="p">:</span> <span class="kc">auto</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">start</span> <span class="o">|</span> <span class="kc">flex</span><span class="o">-</span><span class="kc">end</span> <span class="o">|</span> <span class="kc">center</span> <span class="o">|</span> <span class="kc">baseline</span> <span class="o">|</span> <span class="kc">stretch</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">参考链接</a></p>
]]></content>
		</item>
		
		<item>
			<title>jQuery学习小结</title>
			<link>https://wuchuan.monster/posts/jquery%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</link>
			<pubDate>Sun, 12 Jan 2020 19:43:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/jquery%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93/</guid>
			<description>1. jQuery 如何获取元素 jQuery的基本设计思想和主要用法，就是&amp;quot;选择某个网页元素，然后对其进行某种操作&amp;rdquo;。这是它区别于其他Javascript库的根本特点。
使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。
选择表达式可以是CSS选择器：
$(document) //选择整个文档对象$(&amp;#39;#myId&amp;#39;) //选择ID为myId的网页元素$(&amp;#39;div.myClass&amp;#39;) // 选择class为myClass的div元素$(&amp;#39;input[name=first]&amp;#39;) // 选择name属性等于first的input元素也可以是jQuery特有的表达式：
$(&amp;#39;a:first&amp;#39;) //选择网页中第一个a元素$(&amp;#39;tr:odd&amp;#39;) //选择表格的奇数行$(&amp;#39;#myForm :input&amp;#39;) // 选择表单中的input元素$(&amp;#39;div:visible&amp;#39;) //选择可见的div元素$(&amp;#39;div:gt(2)&amp;#39;) // 选择所有的div元素，除了前三个$(&amp;#39;div:animated&amp;#39;) // 选择当前处于动画状态的div元素2. jQuery 的链式操作是怎样的 jQuery的链式操作，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：
$(&amp;#39;div&amp;#39;).find(&amp;#39;h3&amp;#39;).eq(2).html(&amp;#39;Hello&amp;#39;);分解开来，就是下面这样：
$(&amp;#39;div&amp;#39;) //找到div元素.find(&amp;#39;h3&amp;#39;) //选择其中的h3元素.eq(2) //选择第3个h3元素.html(&amp;#39;Hello&amp;#39;); //将它的内容改为Hello这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。
jQuery还提供了.end()方法，使得结果集可以后退一步：
$(&amp;#39;div&amp;#39;).find(&amp;#39;h3&amp;#39;).eq(2).html(&amp;#39;Hello&amp;#39;).end() //退回到选中所有的h3元素的那一步.eq(0) //选中第一个h3元素.</description>
			<content type="html"><![CDATA[<h3 id="1-jquery-">1. jQuery 如何获取元素</h3>
<p>jQuery的基本设计思想和主要用法，就是&quot;选择某个网页元素，然后对其进行某种操作&rdquo;。这是它区别于其他Javascript库的根本特点。</p>
<p>使用jQuery的第一步，往往就是将一个选择表达式，放进构造函数jQuery()（简写为$），然后得到被选中的元素。</p>
<p>选择表达式可以是CSS选择器：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">)</span> <span class="c1">//选择整个文档对象
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#myId&#39;</span><span class="p">)</span> <span class="c1">//选择ID为myId的网页元素
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div.myClass&#39;</span><span class="p">)</span> <span class="c1">// 选择class为myClass的div元素
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;input[name=first]&#39;</span><span class="p">)</span> <span class="c1">// 选择name属性等于first的input元素
</span></code></pre></div><p>也可以是jQuery特有的表达式：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;a:first&#39;</span><span class="p">)</span> <span class="c1">//选择网页中第一个a元素
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;tr:odd&#39;</span><span class="p">)</span> <span class="c1">//选择表格的奇数行
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;#myForm :input&#39;</span><span class="p">)</span> <span class="c1">// 选择表单中的input元素
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div:visible&#39;</span><span class="p">)</span> <span class="c1">//选择可见的div元素
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div:gt(2)&#39;</span><span class="p">)</span> <span class="c1">// 选择所有的div元素，除了前三个
</span><span class="c1"></span>
<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div:animated&#39;</span><span class="p">)</span> <span class="c1">// 选择当前处于动画状态的div元素
</span></code></pre></div><h3 id="2-jquery-">2. jQuery 的链式操作是怎样的</h3>
<p>jQuery的链式操作，就是最终选中网页元素以后，可以对它进行一系列操作，并且所有操作可以连接在一起，以链条的形式写出来，比如：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;h3&#39;</span><span class="p">)</span><span class="p">.</span><span class="nx">eq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">.</span><span class="nx">html</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>分解开来，就是下面这样：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span> <span class="c1">//找到div元素
</span><span class="c1"></span>
<span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;h3&#39;</span><span class="p">)</span> <span class="c1">//选择其中的h3元素
</span><span class="c1"></span>
<span class="p">.</span><span class="nx">eq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1">//选择第3个h3元素
</span><span class="c1"></span>
<span class="p">.</span><span class="nx">html</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span><span class="p">;</span> <span class="c1">//将它的内容改为Hello
</span></code></pre></div><p>这是jQuery最令人称道、最方便的特点。它的原理在于每一步的jQuery操作，返回的都是一个jQuery对象，所以不同操作可以连在一起。</p>
<p>jQuery还提供了.end()方法，使得结果集可以后退一步：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span>

<span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="s1">&#39;h3&#39;</span><span class="p">)</span>

<span class="p">.</span><span class="nx">eq</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="p">.</span><span class="nx">html</span><span class="p">(</span><span class="s1">&#39;Hello&#39;</span><span class="p">)</span>

<span class="p">.</span><span class="nx">end</span><span class="p">(</span><span class="p">)</span> <span class="c1">//退回到选中所有的h3元素的那一步
</span><span class="c1"></span>
<span class="p">.</span><span class="nx">eq</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">//选中第一个h3元素
</span><span class="c1"></span>
<span class="p">.</span><span class="nx">html</span><span class="p">(</span><span class="s1">&#39;World&#39;</span><span class="p">)</span><span class="p">;</span> <span class="c1">//将它的内容改为World
</span></code></pre></div><h3 id="3-jquery-">3. jQuery 如何创建元素</h3>
<p>创建新元素的方法非常简单，只要把新元素直接传入jQuery的构造函数就行了：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;p&gt;Hello&lt;/p&gt;&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;&lt;li class=&#34;new&#34;&gt;new list item&lt;/li&gt;&#39;</span><span class="p">)</span><span class="p">;</span>

<span class="nx">$</span><span class="p">(</span><span class="s1">&#39;ul&#39;</span><span class="p">)</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="s1">&#39;&lt;li&gt;list item&lt;/li&gt;&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><h3 id="4-jquery-">4. jQuery 如何移动元素</h3>
<p>jQuery移动元素，就是提供两组方法，来操作元素在网页中的位置移动。一组方法是直接移动该元素，另一组方法是移动其他元素，使得目标元素达到我们想要的位置。</p>
<p>假定我们选中了一个div元素，需要把它移动到p元素后面。</p>
<p>第一种方法是使用.insertAfter()，把div元素移动p元素后面：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span><span class="p">.</span><span class="nx">insertAfter</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>第二种方法是使用.after()，把p元素加到div元素前面：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span><span class="p">.</span><span class="nx">after</span><span class="p">(</span><span class="nx">$</span><span class="p">(</span><span class="s1">&#39;div&#39;</span><span class="p">)</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>表面上看，这两种方法的效果是一样的，唯一的不同似乎只是操作视角的不同。但是实际上，它们有一个重大差别，那就是返回的元素不一样。第一种方法返回div元素，第二种方法返回p元素。你可以根据需要，选择到底使用哪一种方法。</p>
<p>使用这种模式的操作方法，一共有四对：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="p">.</span><span class="nx">insertAfter</span><span class="p">(</span><span class="p">)</span><span class="nx">和</span><span class="p">.</span><span class="nx">after</span><span class="p">(</span><span class="p">)</span><span class="err">：</span><span class="nx">在现存元素的外部</span><span class="err">，</span><span class="nx">从后面插入元素</span>

<span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="p">)</span><span class="nx">和</span><span class="p">.</span><span class="nx">before</span><span class="p">(</span><span class="p">)</span><span class="err">：</span><span class="nx">在现存元素的外部</span><span class="err">，</span><span class="nx">从前面插入元素</span>

<span class="p">.</span><span class="nx">appendTo</span><span class="p">(</span><span class="p">)</span><span class="nx">和</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="p">)</span><span class="err">：</span><span class="nx">在现存元素的内部</span><span class="err">，</span><span class="nx">从后面插入元素</span>

<span class="p">.</span><span class="nx">prependTo</span><span class="p">(</span><span class="p">)</span><span class="nx">和</span><span class="p">.</span><span class="nx">prepend</span><span class="p">(</span><span class="p">)</span><span class="err">：</span><span class="nx">在现存元素的内部</span><span class="err">，</span><span class="nx">从前面插入元素</span>
</code></pre></div><h3 id="5-jquery-">5. jQuery 如何修改元素的属性</h3>
<ul>
<li>.addClass() 为每个匹配的元素添加指定的样式类名</li>
<li>.attr()  获取匹配的元素集合中的第一个元素的属性的值。设置每一个匹配元素的一个或多个属性。</li>
<li>.hasClass()
确定任何一个匹配元素是否有被分配给定的（样式）类。</li>
<li>DOM 属性 | DOM 操作 &gt; DOM 插入现有元素内
.html()
获取集合中第一个匹配元素的HTML内容 设置每一个匹配元素的html内容。</li>
<li>.prop()
获取匹配的元素集中第一个元素的属性（property）值为匹配的元素设置一个或多个属性（properties）。</li>
<li>.removeAttr()
为匹配的元素集合中的每个元素中移除一个属性（attribute）。</li>
<li>.removeClass()
移除集合中每个匹配元素上一个，多个或全部样式。</li>
<li>.removeProp()
为集合中匹配的元素删除一个属性（property）。</li>
<li>.toggleClass()
在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类。</li>
<li>.val()
获取匹配的元素集合中第一个元素的当前值。设置匹配的元素集合中每个元素的值。</li>
</ul>
<p>参考链接：</p>
<p><a href="http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html">阮一峰的jQuery设计思想</a></p>
<p><a href="https://www.jquery123.com/category/attributes/">jQuery中文帮助文档</a></p>
]]></content>
		</item>
		
		<item>
			<title>new、call、apply、bine函数的实现</title>
			<link>https://wuchuan.monster/posts/js%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</link>
			<pubDate>Sun, 12 Jan 2020 17:43:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/js%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5/</guid>
			<description>原型,共有属性： 修改共有属性 obj.proto.toString=&#39;xxx&amp;rsquo; //不推荐 Object.prototype.toString=&#39;xxx&amp;rsquo; 修改原型 obj.__proto__=common let obj = Object.create(common)</description>
			<content type="html"><![CDATA[<p>原型,共有属性：
修改共有属性
obj.<strong>proto</strong>.toString='xxx&rsquo; //不推荐
Object.prototype.toString='xxx&rsquo;
修改原型
obj.__proto__=common
let obj = Object.create(common)</p>
]]></content>
		</item>
		
		<item>
			<title>new、call、apply、bine函数的实现</title>
			<link>https://wuchuan.monster/posts/newcallapplybine%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
			<pubDate>Sat, 11 Jan 2020 17:43:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/newcallapplybine%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
			<description>new new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</description>
			<content type="html"><![CDATA[<h2 id="new">new</h2>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
]]></content>
		</item>
		
		<item>
			<title>JavaScript this </title>
			<link>https://wuchuan.monster/posts/this/</link>
			<pubDate>Sat, 11 Jan 2020 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/this/</guid>
			<description>1. 之前我们说过 this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调 用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。
2. 当一个函数被调用时， 会创建一个活动记录（有时候也称为执行上下文）。 这个记录会包 含函数在哪里被调用（调用栈）、 函数的调用方法、 传入的参数等信息。 this 就是记录的 其中一个属性， 会在函数执行的过程中用到。
3. 默认绑定 =&amp;gt; 绑定全局 function foo() {console.log( this.a );}var a = 2;foo(); // 24. 显示绑定（call,apply,bind)  硬绑定  function foo() {console.log(this.a);}var obj = {a: 2};var bar = function() {foo.call(obj);};bar(); // 2setTimeout(bar, 100); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.</description>
			<content type="html"><![CDATA[<h4 id="1--this---">1. 之前我们说过 this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调</h4>
<p>用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。</p>
<h4 id="2---">2. 当一个函数被调用时， 会创建一个活动记录（有时候也称为执行上下文）。 这个记录会包</h4>
<p>含函数在哪里被调用（调用栈）、 函数的调用方法、 传入的参数等信息。 this 就是记录的
其中一个属性， 会在函数执行的过程中用到。</p>
<h4 id="3---">3. 默认绑定 =&gt; 绑定全局</h4>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 2
</span></code></pre></div><h4 id="4-callapplybind">4. 显示绑定（call,apply,bind)</h4>
<ol>
<li>硬绑定</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span>
<span class="p">}</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">foo</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="nx">bar</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 2
</span><span class="c1"></span>
<span class="nx">setTimeout</span><span class="p">(</span><span class="nx">bar</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 2
</span><span class="c1"></span>
<span class="c1">// 硬绑定的 bar 不可能再修改它的 this
</span><span class="c1"></span><span class="nx">bar</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nb">window</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 2
</span></code></pre></div><p>我们来看看这个变种到底是怎样工作的。 我们创建了函数 bar()， 并在它的内部手动调用
了 foo.call(obj)， 因此强制把 foo 的 this 绑定到了 obj。 无论之后如何调用函数 bar， 它总会手动在 obj 上调用 foo。 这种绑定是一种显式的强制绑定， 因此我们称之为硬绑定。</p>
<h4 id="2-api">2. API调用的“上下文”</h4>
<h4 id="5----this-----this--">5. 隐式绑定 =&gt;当函数引用有上下文对象时， 隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。对象属性引用链中只有最顶层或者说最后一层会影响调用位置。在分析隐式绑定时， 我们必须在一个对象内部包含一个指向函数的属性， 并通过这个属性间接引用函数， 从而把 this 间接（隐式） 绑定到这个对象上。</h4>
<div class="highlight"><pre class="chroma"><code class="language-javaScript" data-lang="javaScript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="nx">foo</span>
<span class="p">}</span><span class="p">;</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// 2
</span></code></pre></div><ul>
<li>隐式丢失，一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象， 也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上， 取决于是否是严格模式。</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-javaScript" data-lang="javaScript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="nx">foo</span>
<span class="p">}</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">;</span> <span class="c1">// 函数别名！
</span><span class="c1"></span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&#34;oops, global&#34;</span><span class="p">;</span> <span class="c1">// a 是全局对象的属性
</span><span class="c1"></span>
<span class="nx">bar</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// &#34;oops, global&#34;&#34;
</span></code></pre></div><ul>
<li>回调函数</li>
</ul>
<div class="highlight"><pre class="chroma"><code class="language-javaScript" data-lang="javaScript"><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">doFoo</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// fn 其实引用的是 foo
</span><span class="c1"></span>  <span class="nx">fn</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> <span class="c1">// &lt;-- 调用位置！
</span><span class="c1"></span><span class="p">}</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nx">foo</span><span class="o">:</span> <span class="nx">foo</span>
<span class="p">}</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">&#34;oops, global&#34;</span><span class="p">;</span> <span class="c1">// a 是全局对象的属性
</span><span class="c1"></span><span class="nx">doFoo</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">)</span><span class="p">;</span> <span class="c1">// &#34;oops, global&#34;
</span></code></pre></div><h4 id="6-new">6. new绑定</h4>
<p>首先我们重新定义一下 JavaScript 中的“构造函数”。 在 JavaScript 中， 构造函数只是一些使用 new 操作符时被调用的函数。 它们并不会属于某个类， 也不会实例化一个类。 实际上，它们甚至都不能说是一种特殊的函数类型， 它们只是被 new 操作符调用的普通函数而已。</p>
<p>实际上并不存在所谓的“构造函数”， 只有对于函数的“构造调用”。</p>
<h4 id="7-">7. 优先级</h4>
<pre><code>显式&gt;new&gt;隐式&gt;默认
</code></pre>
<h3 id="heading">特殊引用</h3>
<h4 id="1-">1. 软绑定</h4>
<p>之前我们已经看到过， 硬绑定这种方式可以把 this 强制绑定到指定的对象（除了使用 new
时）， 防止函数调用应用默认绑定规则。 问题在于， 硬绑定会大大降低函数的灵活性， 使
用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。
如果可以给默认绑定指定一个全局对象和 undefined 以外的值， 那就可以实现和硬绑定相
同的效果， 同时保留隐式绑定或者显式绑定修改 this 的能力。</p>
<div class="highlight"><pre class="chroma"><code class="language-javaScript" data-lang="javaScript"><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">softBind</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Function</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">softBind</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">fn</span> <span class="o">=</span> <span class="k">this</span><span class="p">;</span>
    <span class="c1">// 捕获所有 curried 参数
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">curried</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">.</span><span class="nx">slice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">bound</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span>
        <span class="p">(</span><span class="o">!</span><span class="k">this</span> <span class="o">||</span> <span class="k">this</span> <span class="o">===</span> <span class="p">(</span><span class="nb">window</span> <span class="o">||</span> <span class="nx">global</span><span class="p">)</span><span class="p">)</span> <span class="o">?</span>
        <span class="nx">obj</span> <span class="o">:</span> <span class="k">this</span> <span class="nx">curried</span><span class="p">.</span><span class="nx">concat</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">curried</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span>
      <span class="p">)</span><span class="p">;</span>
    <span class="p">}</span><span class="p">;</span>
    <span class="nx">bound</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">bound</span><span class="p">;</span>
  <span class="p">}</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="2-">2. 间接引用</h4>
<p>另一个需要注意的是， 你有可能（有意或者无意地） 创建一个函数的“间接引用”， 在这
种情况下， 调用这个函数会应用默认绑定规则</p>
<p>箭头函数并不是使用 function 关键字定义的， 而是使用被称为“胖箭头” 的操作符 =&gt; 定
义的。 箭头函数不使用 this 的四种标准规则， 而是根据外层（函数或者全局） 作用域来决
定 this。箭头函数的绑定无法被修改。</p>
<h4 id="-">现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断：</h4>
<ol>
<li>函数是否在 new 中调用（new 绑定） ？ 如果是的话 this 绑定的是新创建的对象。
var bar = new foo()</li>
<li>函数是否通过 call、 apply（显式绑定） 或者硬绑定调用？ 如果是的话， this 绑定的是
指定的对象。
var bar = foo.call(obj2)</li>
<li>函数是否在某个上下文对象中调用（隐式绑定） ？ 如果是的话， this 绑定的是那个上
下文对象。
var bar = obj1.foo()</li>
<li>如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到
全局对象。
var bar = foo()</li>
</ol>
<h4 id="-new---">使用 new 来调用函数， 或者说发生构造函数调用时， 会自动执行下面的操作。</h4>
<ol>
<li>创建（或者说构造） 一个全新的对象。</li>
<li>这个新对象会被执行 [[ 原型 ]] 连接。</li>
<li>这个新对象会绑定到函数调用的 this。</li>
<li>如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象.</li>
</ol>
<h4 id="-this---">如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。 找到之后</h4>
<p>就可以顺序应用下面这四条规则来判断 this 的绑定对象。</p>
<ol>
<li>由 new 调用？ 绑定到新创建的对象。</li>
<li>由 call 或者 apply（或者 bind） 调用？ 绑定到指定的对象。</li>
<li>由上下文对象调用？ 绑定到那个上下文对象。</li>
<li>默认： 在严格模式下绑定到 undefined， 否则绑定到全局对象。</li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>JS 函数的执行时机</title>
			<link>https://wuchuan.monster/posts/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</link>
			<pubDate>Sun, 05 Jan 2020 18:58:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/js-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA/</guid>
			<description>1. 解释为什么如下代码会打印 6 个 6 let i = 0for(i = 0; i&amp;lt;6; i++){setTimeout(()=&amp;gt;{console.log(i)},0)}答： 因为 setTimeout() 方法的意思是等一会打印出 i 的值，他要等循环先执行完，才会打印。循环执行完i===6，所以会打印6个6。
 就是for循环要先执行完6次，i变成了6； 然后 setTimeout() 方法在进入循环，打印6次；  2. 写出让上面代码打印 0、1、2、3、4、5 的方法 答： for(let i = 0; i&amp;lt;6; i++){setTimeout(()=&amp;gt;{console.log(i)},0)}3. 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5 答： let i = 0;while (i &amp;lt; 5) {i++;console.log(i)}</description>
			<content type="html"><![CDATA[<h3 id="1--6--6">1. 解释为什么如下代码会打印 6 个 6</h3>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h4 id="heading">答：</h4>
<p>因为 <strong>setTimeout()</strong> 方法的意思是等一会打印出 <strong>i</strong> 的值，他要等循环先执行完，才会打印。循环执行完<strong>i===6</strong>，所以会打印6个6。</p>
<ol>
<li>就是for循环要先执行完6次，<strong>i</strong>变成了6；</li>
<li>然后 <strong>setTimeout()</strong> 方法在进入循环，打印6次；</li>
</ol>
<h3 id="2--012345-">2. 写出让上面代码打印 0、1、2、3、4、5 的方法</h3>
<h4 id="heading-1">答：</h4>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3 id="3--for-let--012345">3. 除了使用 for let 配合，还有什么其他方法可以打印出 0、1、2、3、4、5</h3>
<h4 id="heading-2">答：</h4>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>]]></content>
		</item>
		
		<item>
			<title>JavaSript的诞生</title>
			<link>https://wuchuan.monster/posts/javasript%E7%9A%84%E8%AF%9E%E7%94%9F/</link>
			<pubDate>Wed, 01 Jan 2020 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/javasript%E7%9A%84%E8%AF%9E%E7%94%9F/</guid>
			<description>JavaScirpt 创始人 1995 年，网景招募了布兰登·艾克，目标是把 Scheme 语言嵌入到 Netscape Navigator 浏览器当中。但更早之前，网景已经跟昇阳合作在 Netscape Navigator 中支持 Java，这时网景内部产生激烈的争论。后来网景决定发明一种与 Java 搭配使用的辅助脚本语言并且语法上有些类似，这个决策导致排除了采用现有的语言，例如 Perl、Python、Tcl 或 Scheme。为了在其他竞争提案中捍卫 JavaScript 这个想法，公司需要有一个可以运作的原型。艾克在 1995 年 5 月仅花了十天时间就把原型设计出来了。
JavaScirpt 标准化 1996 年 11 月，网景正式向 ECMA（欧洲计算机制造商协会）提交语言标准。1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。JavaScript 成为了 ECMAScript 最著名的实现之一[16]。除此之外，ActionScript 和 JScript 也都是 ECMAScript 规范的实现语言。尽管 JavaScript 作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是 JavaScript 具有非常丰富的特性。
 1997 年 6 月，第一版 ECMAScript 发布 1999 年 12 月，第三版发布，这个版本使用最广 2009 年 12 月，第五版发布，增加了一些新功能 2015 年 6 月，第六版发布，新浏览器都支持这一版本 之后每年发布一版，版本号以年饭命名  JavaScirpt 和 ECMAScript 的关系  ECMAScript 是纸上的标准，JS 是浏览器的实现 纸上标准往往落后于浏览器，先实现，再写进标准  JS 的兴起  IE 市场份额巨大导致 JS 停滞了 10 年，直至 Chrome 主导市场地位，才有了后面的每年更新 移动市场的兴起，手机上没人会安装 IE 浏览器 2004 年愚人节，谷歌发布 Gmail 在线网页为前端带来无限可能 2005 年，Jesse 将谷歌用到的技术命名为 AJAX，前端技术正式出现 2006 年，jQuery 发布，是目前最长寿的 JS 库，后来 IE 不行了，jQuery 才稍微没那么火  JS 爆发  Chrome 的 JS 引擎叫做 V8 2009 年，Ryan 基于 V8 创建了 Node.</description>
			<content type="html"><![CDATA[<h4 id="javascirpt-">JavaScirpt 创始人</h4>
<p><img src="/images/BEich.jpg" alt="URL"></p>
<p>1995 年，网景招募了布兰登·艾克，目标是把 Scheme 语言嵌入到 Netscape Navigator 浏览器当中。但更早之前，网景已经跟昇阳合作在 Netscape Navigator 中支持 Java，这时网景内部产生激烈的争论。后来网景决定发明一种与 Java 搭配使用的辅助脚本语言并且语法上有些类似，这个决策导致排除了采用现有的语言，例如 Perl、Python、Tcl 或 Scheme。为了在其他竞争提案中捍卫 JavaScript 这个想法，公司需要有一个可以运作的原型。艾克在 1995 年 5 月仅花了十天时间就把原型设计出来了。</p>
<h3 id="javascirpt--1">JavaScirpt 标准化</h3>
<p>1996 年 11 月，网景正式向 ECMA（欧洲计算机制造商协会）提交语言标准。1997 年 6 月，ECMA 以 JavaScript 语言为基础制定了 ECMAScript 标准规范 ECMA-262。JavaScript 成为了 ECMAScript 最著名的实现之一[16]。除此之外，ActionScript 和 JScript 也都是 ECMAScript 规范的实现语言。尽管 JavaScript 作为给非程序人员的脚本语言，而非作为给程序人员的脚本语言来推广和宣传，但是 JavaScript 具有非常丰富的特性。</p>
<ul>
<li>1997 年 6 月，第一版 ECMAScript 发布</li>
<li>1999 年 12 月，第三版发布，这个版本使用最广</li>
<li>2009 年 12 月，第五版发布，增加了一些新功能</li>
<li>2015 年 6 月，第六版发布，新浏览器都支持这一版本</li>
<li>之后每年发布一版，版本号以年饭命名</li>
</ul>
<h3 id="javascirpt--ecmascript-">JavaScirpt 和 ECMAScript 的关系</h3>
<ul>
<li>ECMAScript 是纸上的标准，JS 是浏览器的实现</li>
<li>纸上标准往往落后于浏览器，先实现，再写进标准</li>
</ul>
<h3 id="js-">JS 的兴起</h3>
<ul>
<li>IE 市场份额巨大导致 JS 停滞了 10 年，直至 Chrome 主导市场地位，才有了后面的每年更新</li>
<li>移动市场的兴起，手机上没人会安装 IE 浏览器</li>
<li>2004 年愚人节，谷歌发布 Gmail 在线网页为前端带来无限可能</li>
<li>2005 年，Jesse 将谷歌用到的技术命名为 AJAX，前端技术正式出现</li>
<li>2006 年，jQuery 发布，是目前最长寿的 JS 库，后来 IE 不行了，jQuery 才稍微没那么火</li>
</ul>
<h3 id="js--1">JS 爆发</h3>
<ul>
<li>Chrome 的 JS 引擎叫做 V8</li>
<li>2009 年，Ryan 基于 V8 创建了 Node.js</li>
<li>2010 年 Isaac 基于 Node.js 写出了 npm,前端工程师可以在浏览器之外执行 JS 了，Node.js 快速风靡</li>
<li>同年，TJ 受 Sinatra 启发，发不了 Express.js，从此，前端工程师可以愉快的写后端应用了</li>
</ul>
<h3 id="heading">总结</h3>
<ul>
<li>JS 是历史的选择
<ul>
<li>一开始浏览器支持很多东西：Java、Flash、VBScript</li>
<li>只有 JS 活到了最后</li>
</ul>
</li>
<li>JS 的低开高走
<ul>
<li>一开始 JS 就是一个玩具语言，但是 JS 每次都走对了风口</li>
</ul>
</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>JS对象的基本用法</title>
			<link>https://wuchuan.monster/posts/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
			<pubDate>Wed, 01 Jan 2020 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/js%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
			<description>1. 声明对象的两种语法 示例：
let obj = {&amp;#39;name&amp;#39;: &amp;#39;frank&amp;#39;, &amp;#39;age&amp;#39;: 18}let obj = new Object({&amp;#39;name&amp;#39;: &amp;#39;frank&amp;#39;, &amp;#39;age&amp;#39;: 18})// 一般使用第一种2. 如何删除对象的属性   delete 命令用于删除对象的属性，删除成功后返回 true。
  delete obj.xxx 或者 delete obj[&amp;lsquo;xxx&amp;rsquo;] 这俩种都可以删除对象属性。
  下面代码中，delete命令删除对象obj的p属性。删除后，再读取p属性就会返回undefined，而且Object.keys方法的返回值也不再包括该属性。
var obj = { p: 1 };Object.keys(obj) // [&amp;#34;p&amp;#34;]delete obj.p // trueobj.p // undefinedObject.keys(obj) // []  3. 如何查看对象的属性   查看一个对象本身的所有属性，可以使用Object.keys方法。
var obj = {key1: 1,key2: 2};Object.</description>
			<content type="html"><![CDATA[<h3 id="1-">1. 声明对象的两种语法</h3>
<p>示例：</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="s1">&#39;frank&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="o">:</span> <span class="mi">18</span><span class="p">}</span>

<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">(</span><span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="o">:</span> <span class="s1">&#39;frank&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="o">:</span> <span class="mi">18</span><span class="p">}</span><span class="p">)</span>
<span class="c1">// 一般使用第一种
</span></code></pre></div><h3 id="2-">2. 如何删除对象的属性</h3>
<ul>
<li>
<p>delete 命令用于删除对象的属性，删除成功后返回 true。</p>
</li>
<li>
<p>delete obj.xxx 或者 delete obj[&lsquo;xxx&rsquo;] 这俩种都可以删除对象属性。</p>
</li>
<li>
<p>下面代码中，<strong>delete</strong>命令删除对象<strong>obj</strong>的<strong>p</strong>属性。删除后，再读取<strong>p</strong>属性就会返回<strong>undefined</strong>，而且<strong>Object.keys</strong>方法的返回值也不再包括该属性。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">p</span><span class="o">:</span> <span class="mi">1</span> <span class="p">}</span><span class="p">;</span>
<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// [&#34;p&#34;]
</span><span class="c1"></span><span class="k">delete</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nx">p</span> <span class="c1">// undefined
</span><span class="c1"></span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// []
</span></code></pre></div></li>
</ul>
<h3 id="3-">3. 如何查看对象的属性</h3>
<ul>
<li>
<p>查看一个对象本身的所有属性，可以使用<strong>Object.keys</strong>方法。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
<span class="nx">key1</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
<span class="nx">key2</span><span class="o">:</span> <span class="mi">2</span>
  <span class="p">}</span><span class="p">;</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// [&#39;key1&#39;, &#39;key2&#39;]
</span></code></pre></div></li>
</ul>
<h3 id="4-">4. 如何修改或增加对象的属性</h3>
<ul>
<li>
<p>修改自身属性，直接赋值，如下代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">name</span><span class="o">:</span> <span class="s2">&#34;frank&#34;</span> <span class="p">}</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="c1">//&#34;frank&#34;
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="s2">&#34;name&#34;</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">===</span> <span class="s2">&#34;frank&#34;</span><span class="p">;</span> <span class="c1">//true
</span></code></pre></div></li>
<li>
<p>批量赋值，如下代码:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="p">{</span> <span class="nx">color</span><span class="o">:</span> <span class="s2">&#34;red&#34;</span><span class="p">,</span> <span class="nx">age</span><span class="o">:</span> <span class="mi">18</span> <span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>修改共有属性</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">[</span><span class="s2">&#34;toString&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;xxx&#34;</span><span class="p">;</span>
<span class="c1">//
</span><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span><span class="p">[</span><span class="s2">&#34;toString&#34;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&#34;xxx&#34;</span><span class="p">;</span>
<span class="c1">//不推荐这种
</span></code></pre></div></li>
<li>
<p>改原型</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">common</span><span class="p">)</span><span class="p">;</span>
<span class="c1">//
</span><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nx">__proto__</span> <span class="o">=</span> <span class="nx">common</span><span class="p">;</span>
<span class="c1">//不推荐这种
</span></code></pre></div></li>
<li>
<p>增加属性</p>
<p>基本和改一样，已有属性则该，没有属性就增加；</p>
</li>
</ul>
<h3 id="5-name-in-obj--objhasownpropertyname-">5. &lsquo;name&rsquo; in obj 和 obj.hasOwnProperty(&lsquo;name&rsquo;) 的区别</h3>
<ul>
<li>他们俩个都是判断属性名是否存在在对象里</li>
<li>区别是<strong>in</strong> 会继承原型链上的属性，而 obj.hasOwnPropert 不会继承原型链的属性。</li>
</ul>
]]></content>
		</item>
		
		<item>
			<title>JS的基本语法</title>
			<link>https://wuchuan.monster/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link>
			<pubDate>Wed, 01 Jan 2020 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/js%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid>
			<description>什么是表达式和语句 JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。
语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。
var a = 1 + 3;这条语句先用 var 命令，声明了变量 a ，然后将 1 + 3 的运算结果赋值给变量 a。
1 + 3叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。
语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。
var a = 1 + 3 ; var b = &amp;#39;abc&amp;#39;;分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。
;;;上面的代码就表示 3 个空语句。
表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。
1 + 3;&amp;#39;abc&amp;#39;;上面两行语句只是单纯地产生一个值，并没有任何实际的意义。
   标识符的规则 标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以 a 和 A 是两个不同的标识符。
标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。
 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 0-9。  简单说，标识符命名规则如下。</description>
			<content type="html"><![CDATA[<ol>
<li>
<p>什么是表达式和语句
JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<p>语句（statement）是为了完成某种任务而进行的操作，比如下面就是一行赋值语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
</code></pre></div><p>这条语句先用 <strong>var</strong> 命令，声明了变量 <strong>a</strong> ，然后将 <strong>1 + 3</strong> 的运算结果赋值给变量 a。</p>
<p><strong>1 + 3</strong>叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。</p>
<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">;</span> <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="s1">&#39;abc&#39;</span><span class="p">;</span>
</code></pre></div><p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="p">;</span><span class="p">;</span><span class="p">;</span>
</code></pre></div><p>上面的代码就表示 3 个空语句。</p>
<p>表达式不需要分号结尾。一旦在表达式后面添加分号，则 JavaScript 引擎就将表达式视为语句，这样会产生一些没有任何意义的语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
<span class="s1">&#39;abc&#39;</span><span class="p">;</span>
</code></pre></div><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义。</p>
</li>
</ol>
<ol start="2">
<li>
<p>标识符的规则
标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以 <strong>a</strong> 和 <strong>A</strong> 是两个不同的标识符。</p>
<p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。</p>
<ul>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字 0-9。</li>
</ul>
<p>简单说，标识符命名规则如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">arg0</span>
<span class="nx">_tmp</span>
<span class="nx">$elem</span>
<span class="nx">π</span>
</code></pre></div><p>下面这些则是不合法的标识符。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="mi">1</span><span class="nx">a</span>  <span class="c1">// 第一个字符不能是数字
</span><span class="c1"></span><span class="mi">23</span>  <span class="c1">// 同上
</span><span class="c1"></span><span class="o">*</span><span class="o">*</span><span class="o">*</span>  <span class="c1">// 标识符不能包含星号
</span><span class="c1"></span><span class="nx">a</span><span class="o">+</span><span class="nx">b</span>  <span class="c1">// 标识符不能包含加号
</span><span class="c1"></span><span class="o">-</span><span class="nx">d</span>  <span class="c1">// 标识符不能包含减号或连词线
</span></code></pre></div><p>中文是合法的标识符，可以用作变量名。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">临时变量</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div></li>
<li>
<p>if else 语句</p>
<h4 id="if-">if 结构</h4>
<p><strong>if</strong>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，<strong>true</strong>表示真，<strong>false</strong>表示伪。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">布尔值</span><span class="p">)</span>
    <span class="nx">语句</span><span class="p">;</span>

<span class="c1">// 或者
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="nx">布尔值</span><span class="p">)</span> <span class="nx">语句</span><span class="p">;</span>
</code></pre></div><p>上面是<strong>if</strong>结构的基本形式。需要注意的是，“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值。如果表达式的求值结果为<strong>true</strong>，就执行紧跟在后面的语句；如果结果为<strong>false</strong>，则跳过紧跟在后面的语句。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span>
    <span class="nx">m</span> <span class="o">=</span> <span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></div><p>上面代码表示，只有在<strong>m</strong>等于 3 时，才会将其值加上 1。</p>
<p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<strong>if</strong>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">m</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>建议总是在<strong>if</strong>语句中使用大括号，因为这样方便插入语句。</p>
<p>注意，if 后面的表达式之中，不要混淆赋值表达式（=）、严格相等运算符（===）和相等运算符（==）。尤其是赋值表达式不具有比较作用。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// &#34;2&#34;
</span></code></pre></div><p>上面代码的原意是，当<strong>x</strong>等于<strong>y</strong>的时候，才执行相关语句。但是，不小心将严格相等运算符写成赋值表达式，结果变成了将<strong>y</strong>赋值给变量<strong>x</strong>，再判断变量 x 的值（等于 2）的布尔值（结果为<strong>true</strong>）。</p>
<p>这种错误可以正常生成一个布尔值，因而不会报错。为了避免这种情况，有些开发者习惯将常量写在运算符的左边，这样的话，一旦不小心将相等运算符写成赋值运算符，就会报错，因为常量不能被赋值。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不报错
</span><span class="c1"></span><span class="k">if</span> <span class="p">(</span><span class="mi">2</span> <span class="o">=</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 报错
</span></code></pre></div><h4 id="ifelse-">if&hellip;else 结构</h4>
<p><strong>if</strong>代码块后面，还可以跟一个<strong>else</strong>代码块，表示不满足条件时，所要执行的代码。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// 满足条件时，执行的语句
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">// 不满足条件时，执行的语句
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>上面代码判断变量<strong>m</strong>是否等于3，如果等于就执行<strong>if</strong>代码块，否则执行<strong>else</strong>代码块。</p>
<p>对同一个变量进行多次判断时，多个<strong>if&hellip;else</strong>语句可以连写在一起。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>else代码块总是与离自己最近的那个if语句配对。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="k">else</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>上面代码不会有任何输出，else代码块不会得到执行，因为它跟着的是最近的那个if语句，相当于下面这样。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>
</code></pre></div><p>如果想让else代码块跟随最上面的那个if语句，就要改变大括号的位置。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">if</span> <span class="p">(</span><span class="nx">m</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;world&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// world
</span></code></pre></div></li>
</ol>
<ol>
<li>
<p>while for 语句</p>
<h4 id="while-">while 循环</h4>
<p><strong>while</strong>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">while</span> <span class="p">(</span><span class="nx">条件</span><span class="p">)</span>
    <span class="nx">语句</span><span class="p">;</span>

<span class="c1">// 或者
</span><span class="c1"></span><span class="k">while</span> <span class="p">(</span><span class="nx">条件</span><span class="p">)</span> <span class="nx">语句</span><span class="p">;</span>
</code></pre></div><p><strong>while</strong>语句的循环条件是一个表达式，必须放在圆括号中。代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">while</span> <span class="p">(</span><span class="nx">条件</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">语句</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>下面是<strong>while</strong>语句的一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;i 当前为：&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)</span><span class="p">;</span>
    <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上面的代码将循环 100 次，直到 i 等于 100 为止。</p>
<p>下面的例子是一个无限循环，因为循环条件总是为真。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello world&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><h4 id="for-">for 循环</h4>
<p><strong>for</strong>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">for</span> <span class="p">(</span><span class="nx">初始化表达式</span><span class="p">;</span> <span class="nx">条件</span><span class="p">;</span> <span class="nx">递增表达式</span><span class="p">)</span>
    <span class="nx">语句</span>

<span class="c1">// 或者
</span><span class="c1"></span>
<span class="k">for</span> <span class="p">(</span><span class="nx">初始化表达式</span><span class="p">;</span> <span class="nx">条件</span><span class="p">;</span> <span class="nx">递增表达式</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">语句</span>
<span class="p">}</span>
</code></pre></div><p><strong>for</strong>语句后面的括号里面，有三个表达式。</p>
<ul>
<li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<p>下面是一个例子。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 0
</span><span class="c1"></span><span class="c1">// 1
</span><span class="c1"></span><span class="c1">// 2
</span></code></pre></div><p>上面代码中，初始化表达式是 var i = 0，即初始化一个变量 i；测试表达式是 i &lt; x，即只要 i 小于 x，就会执行循环；递增表达式是 i++，即每次循环结束后，i 增大 1。</p>
<p>所有for循环，都可以改写成while循环。上面的例子改为while循环，代码如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="p">;</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span><span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Hello World&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环。</p>
</li>
<li>
<p>break continue</p>
<p><strong>break</strong>语句和<strong>continue</strong>语句都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<p><strong>break</strong>语句用于跳出代码块或循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;i 当前为: &#39;</span> <span class="o">+</span>  <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nx">i</span> <span class="o">===</span> <span class="mi">10</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上面代码只会执行 10 次循环，一旦<strong>i</strong>等于 10，就会跳出循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>     <span class="p">{</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// 0
</span><span class="c1"></span><span class="c1">// 1
</span><span class="c1"></span><span class="c1">// 2
</span><span class="c1"></span><span class="c1">// 3
</span></code></pre></div><p>上面代码执行到<strong>i</strong>等于 3，就会跳出循环。</p>
<p><strong>continue</strong>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<p><strong>for</strong>循环也可以使用<strong>break</strong>语句跳出循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">while</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">)</span><span class="p">{</span>
<span class="nx">i</span><span class="o">++</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;i 当前为：&#39;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>上面代码只有在<strong>i</strong>为奇数时，才会输出<strong>i</strong>的值。如果 i 为偶数，则直接进入下一轮循环。</p>
<p>如果存在多重循环，不带参数的 break 语句和<strong>continue</strong>语句都只针对最内层循环。</p>
</li>
<li>
<p>label</p>
<p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">label</span><span class="o">:</span>
<span class="nx">语句</span>
</code></pre></div><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与<strong>break</strong>语句和<strong>continue</strong>语句配合使用，跳出特定的循环。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">top</span><span class="o">:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">break</span> <span class="nx">top</span><span class="p">;</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;i=&#39;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;, j=&#39;</span> <span class="o">+</span> <span class="nx">j</span><span class="p">)</span><span class="p">;</span>
         <span class="p">}</span>
    <span class="p">}</span>
<span class="c1">// i=0, j=0
</span><span class="c1"></span><span class="c1">// i=0, j=1
</span><span class="c1"></span><span class="c1">// i=0, j=2
</span><span class="c1"></span><span class="c1">// i=1, j=0
</span></code></pre></div><p>上面代码为一个双重循环区块，break 命令后面加上了 top 标签（注意，top 不用加引号），满足条件时，直接跳出双层循环。如果 break 语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">foo</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
    <span class="k">break</span> <span class="nx">foo</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;本行不会输出&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// 1
</span><span class="c1"></span><span class="c1">// 2
</span></code></pre></div><p>上面代码执行到<strong>break foo</strong>，就会跳出区块。</p>
<p>continue 语句也可以与标签配合使用。</p>
<div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="nx">top</span><span class="o">:</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span><span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">===</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">continue</span> <span class="nx">top</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;i=&#39;</span> <span class="o">+</span> <span class="nx">i</span> <span class="o">+</span> <span class="s1">&#39;, j=&#39;</span> <span class="o">+</span> <span class="nx">j</span><span class="p">)</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="c1">// i=0, j=0
</span><span class="c1"></span><span class="c1">// i=0, j=1
</span><span class="c1"></span><span class="c1">// i=0, j=2
</span><span class="c1"></span><span class="c1">// i=1, j=0
</span><span class="c1"></span><span class="c1">// i=2, j=0
</span><span class="c1"></span><span class="c1">// i=2, j=1
</span><span class="c1"></span><span class="c1">// i=2, j=2
</span></code></pre></div><p>上面代码中，<strong>continue</strong>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<strong>continue</strong>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
</li>
</ol>
<h3 id="7-">7. 参考链接</h3>
<p>摘录至阮一峰的 JavaScript 教程<a href="https://wangdoc.com/javascript/basic/grammar.html#%E6%A0%87%E8%AF%86%E7%AC%A6">JavaScript 教程</a></p>
]]></content>
		</item>
		
		<item>
			<title>CSS 知识总结</title>
			<link>https://wuchuan.monster/posts/css-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</link>
			<pubDate>Tue, 31 Dec 2019 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/css-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</guid>
			<description>一. 浏览器渲染原理 CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。
 DOM 树与 CSSOM 树合并后形成渲染树。 渲染树只包含渲染网页所需的节点。 布局计算每个对象的精确位置和大小。 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。  第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。
二. CSS 动画的两种做法（transition 和 animation）   transition CSS 属性是 transition-property(属性名)，transition-duration(时长)，transition-timing-function(过渡方式) 和 transition-delay(延时) 的一个简写属性。
transition一般配合transform使用；
transform属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改 CSS 视觉格式化模型的坐标空间来实现的。 transform有四个常用属性
 translate 位移 scale 缩放(甚用会出现图片模糊) rotate 旋转 skew 倾斜 他们都作用在 X,Y,Z 轴上； 下面这段代码定义了属性 transition,动画时长 1s，线性移动；    &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;!--HTML--&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;utf-8&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;JS Bin&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;wrapper&amp;#34;&amp;gt; &amp;lt;div id=&amp;#34;demo&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;button id=&amp;#34;button&amp;#34;&amp;gt;开始&amp;lt;/button&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; /*CSS*/ #demo{ width: 100px; height: 100px; border: 1px solid red; margin: 50px; transition: transform 1s linear; } #demo.</description>
			<content type="html"><![CDATA[<h3 id="-">一. 浏览器渲染原理</h3>
<p>CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>
<ul>
<li>DOM 树与 CSSOM 树合并后形成渲染树。</li>
<li>渲染树只包含渲染网页所需的节点。</li>
<li>布局计算每个对象的精确位置和大小。</li>
<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>
</ul>
<p>第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<p><img src="/images/render-tree-construction.jpg" alt="Image"></p>
<h3 id="-css-transition--animation">二. CSS 动画的两种做法（transition 和 animation）</h3>
<ol>
<li>
<p><strong>transition CSS</strong> 属性是 transition-property(属性名)，transition-duration(时长)，transition-timing-function(过渡方式) 和 transition-delay(延时) 的一个简写属性。</p>
<p><strong>transition</strong>一般配合<strong>transform</strong>使用；</p>
<p><strong>transform</strong>属性允许你旋转，缩放，倾斜或平移给定元素。这是通过修改 CSS 视觉格式化模型的坐标空间来实现的。
<strong>transform</strong>有四个常用属性</p>
<ul>
<li>translate 位移</li>
<li>scale 缩放(甚用会出现图片模糊)</li>
<li>rotate 旋转</li>
<li>skew 倾斜
他们都作用在 X,Y,Z 轴上；
下面这段代码定义了属性 transition,动画时长 1s，线性移动；</li>
</ul>
</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="c">&lt;!--</span><span class="c">HTML</span><span class="c">--&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p"></span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;utf-8&#34;</span> <span class="p">/</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p"></span><span class="p">&gt;</span>JS Bin<span class="p">&lt;</span><span class="p">/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;wrapper&#34;</span><span class="p"></span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;demo&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;button&#34;</span><span class="p"></span><span class="p">&gt;</span>开始<span class="p">&lt;</span><span class="p">/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="c">/*CSS*/</span>
<span class="p">#</span><span class="nn">demo</span><span class="p">{</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border</span><span class="p">:</span> <span class="mi">1</span><span class="kt">px</span> <span class="kc">solid</span> <span class="kc">red</span><span class="p">;</span>
  <span class="k">margin</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">transition</span><span class="p">:</span> <span class="k">transform</span> <span class="mi">1</span><span class="kt">s</span> <span class="kc">linear</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">#</span><span class="nn">demo</span><span class="p">.</span><span class="nc">b</span><span class="p">{</span>
  <span class="k">transform</span><span class="p">:</span> <span class="nb">translateX</span><span class="p">(</span><span class="mi">200</span><span class="kt">px</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">demo</span><span class="p">.</span><span class="nc">c</span><span class="p">{</span>
  <span class="k">transform</span><span class="p">:</span> <span class="nb">translateX</span><span class="p">(</span><span class="mi">200</span><span class="kt">px</span><span class="p">)</span> <span class="nb">translateY</span><span class="p">(</span><span class="mi">100</span><span class="kt">px</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-JavaScript" data-lang="JavaScript"><span class="c1">//JavaScript
</span><span class="c1"></span><span class="nx">button</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">(</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span>

  <span class="nx">demo</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="p">(</span><span class="p">)</span><span class="p">=&gt;</span><span class="p">{</span>
    <span class="nx">demo</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">remove</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
    <span class="nx">demo</span><span class="p">.</span><span class="nx">classList</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">)</span>
  <span class="p">}</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p>最终效果：</p>
<p><img src="/images/%E7%A4%BA%E4%BE%8B.gif" alt="示例"></p>
<ol>
<li><strong>animation</strong>属性是 animation-name(动画名)，animation-duration(持续时长) animation-timing-function(延时)，animation-delay(延时)，animation-iteration-count(次数)，animation-direction(方向)，animation-fill-mode(填充模式) 和 animation-play-state(状态) 属性的一个简写属性形式。</li>
</ol>
<p>下面是一个关于<strong>animation</strong>使用的案例：</p>
<div class="highlight"><pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p"></span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">head</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;utf-8&#34;</span> <span class="p">/</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">title</span><span class="p"></span><span class="p">&gt;</span>JS Bin<span class="p">&lt;</span><span class="p">/</span><span class="nt">title</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">head</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">body</span><span class="p"></span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;heart&#34;</span><span class="p"></span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;left&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;right&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">class</span><span class="o">=</span><span class="s">&#34;bottom&#34;</span><span class="p"></span><span class="p">&gt;</span><span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="p">/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="p">/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="p">/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></div><div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="c">/*CSS*/</span>
<span class="o">*</span><span class="p">{</span><span class="k">box-sizing</span><span class="p">:</span> <span class="kc">border-box</span><span class="p">;</span><span class="p">}</span>
<span class="p">#</span><span class="nn">heart</span><span class="p">{</span>
  <span class="k">display</span><span class="p">:</span> <span class="kc">inline</span><span class="o">-</span><span class="kc">block</span><span class="p">;</span>
  <span class="k">margin</span><span class="p">:</span> <span class="mi">100</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">relative</span><span class="p">;</span>
  <span class="k">animation</span><span class="p">:</span> <span class="mf">.5</span><span class="kt">s</span> <span class="n">heart</span> <span class="kc">infinite</span> <span class="kc">alternate</span><span class="o">-</span><span class="kc">reverse</span><span class="p">;</span>

<span class="p">}</span>
<span class="p">@</span><span class="k">keyframes</span> <span class="nt">heart</span> <span class="p">{</span>
  <span class="nt">0</span><span class="o">%</span><span class="p">{</span>
    <span class="k">transform</span><span class="p">:</span> <span class="nb">scale</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nt">100</span><span class="o">%</span><span class="p">{</span>
    <span class="k">transform</span><span class="p">:</span> <span class="nb">scale</span><span class="p">(</span><span class="mf">1.2</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">#</span><span class="nn">heart</span><span class="o">&gt;</span><span class="p">.</span><span class="nc">left</span><span class="p">{</span>
  <span class="k">background</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">absolute</span><span class="p">;</span>
  <span class="k">transform</span><span class="p">:</span> <span class="nb">rotate</span><span class="p">(</span><span class="mi">45</span><span class="kt">deg</span><span class="p">)</span> <span class="nb">translateX</span><span class="p">(</span><span class="mi">31</span><span class="kt">px</span><span class="p">)</span><span class="p">;</span>
  <span class="k">bottom</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">left</span><span class="p">:</span> <span class="mi">-50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-radius</span><span class="p">:</span> <span class="mi">50</span><span class="kt">%</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">50</span><span class="kt">%</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">heart</span><span class="o">&gt;</span><span class="p">.</span><span class="nc">right</span><span class="p">{</span>
  <span class="k">background</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-radius</span><span class="p">:</span> <span class="mi">50</span><span class="kt">%</span><span class="p">;</span>
  <span class="k">position</span><span class="p">:</span> <span class="kc">absolute</span><span class="p">;</span>
  <span class="k">transform</span><span class="p">:</span> <span class="nb">rotate</span><span class="p">(</span><span class="mi">45</span><span class="kt">deg</span><span class="p">)</span> <span class="nb">translateY</span><span class="p">(</span><span class="mi">31</span><span class="kt">px</span><span class="p">)</span><span class="p">;</span>
  <span class="k">bottom</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">right</span><span class="p">:</span> <span class="mi">-50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">border-radius</span><span class="p">:</span> <span class="mi">50</span><span class="kt">%</span> <span class="mi">50</span><span class="kt">%</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">#</span><span class="nn">heart</span><span class="o">&gt;</span><span class="p">.</span><span class="nc">bottom</span><span class="p">{</span>
  <span class="k">background</span><span class="p">:</span> <span class="kc">red</span><span class="p">;</span>
  <span class="k">width</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">height</span><span class="p">:</span> <span class="mi">50</span><span class="kt">px</span><span class="p">;</span>
  <span class="k">transform</span><span class="p">:</span> <span class="nb">rotate</span><span class="p">(</span><span class="mi">45</span><span class="kt">deg</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>最终效果：</p>
<p><img src="/images/%E7%A4%BA%E4%BE%8B2.gif" alt="gif"></p>
<h3 id="-css-">三. CSS 学法总结</h3>
<ol>
<li>CSS 的规则是没有规则</li>
<li>务必掌握 float、flex 布局，了解 grid 布局</li>
<li>不懂的 MDN</li>
<li>调试大法！调试大法！调试大法！</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="nt">border</span><span class="p">:</span><span class="nd">1px</span> <span class="nt">solid</span> <span class="nt">red</span><span class="o">;</span>
</code></pre></div><ol start="5">
<li>起手式！起手式！起手式！</li>
</ol>
<div class="highlight"><pre class="chroma"><code class="language-CSS" data-lang="CSS"><span class="o">*</span><span class="p">{</span><span class="k">margin</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span><span class="k">padding</span><span class="p">:</span><span class="mi">0</span><span class="p">;</span><span class="k">box-sizing</span><span class="p">:</span> <span class="kc">border-box</span><span class="p">;</span><span class="p">}</span>
</code></pre></div><ol start="6">
<li>一定要动手调试每一个属性</li>
</ol>
<!-- raw HTML omitted -->
]]></content>
		</item>
		
		<item>
			<title>浅析URL</title>
			<link>https://wuchuan.monster/posts/%E6%B5%85%E6%9E%90-url/</link>
			<pubDate>Sat, 28 Dec 2019 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/%E6%B5%85%E6%9E%90-url/</guid>
			<description>一. URL 有哪几部分？ URL 包括 &amp;ldquo;协议+域名或 IP+端口号+路径+查询字符串+锚点&amp;rdquo; http：//或 https：//
&amp;ldquo;http&amp;quot;代表超文本传输 ​​ 协议。让浏览器知道它将使用哪种协议来访问 domain 中指定的信息。“ https”协议是“超文本传输 ​​ 协议安全”的缩写，表示通过 HTTP 传输的信息已加密且安全。在 http 或 https 之后是冒号（：）和两个正斜杠（//），用于将协议与 URL 的其余部分分隔开。
www
接下来，“ www”代表万维网，用于区分内容。URL 的这一部分不是必需的，可以省去很多次。例如，键入“ http://computerhope.com ”仍然可以将您带到 Computer Hope 网站。地址的这一部分也可以代替重要的子页面，称为 subdomain。
computerhope.com
接下来，“ computerhope.com”是网站的域名。域的最后一部分称为域后缀，即 TLD。它用于标识网站的类型或位置。例如，“。com”是商业名称的缩写，“。org”是组织的缩写，“。co.uk”是英国。还有许多其他域后缀可用。要获取域名，您可以通过域名注册商注册名称。
/jargon/u/ 接下来的“行话”和上述网址的“U”形部分是目录在网页所在的服务器上。在此示例中，网页有两个目录，因此，如果您尝试在服务器上查找文件，则该文件将位于/public_html/jargon/u 目录中。对于大多数服务器，public_html 目录是包含 HTML 文件的默认目录。
url.htm
最后，url.htm 是您正在查看的域上的实际网页。尾随的.htm 是网页的文件扩展名，指示该文件是 HTML 文件。Internet 上的其他常见文件扩展名包括.html，.php，.asp，.cgi，.xml，.jpg 和.gif。这些文件扩展名中的每一个都执行不同的功能，就像计算机上所有不同类型的文件一样。
二. DNS 的作用是什么，nslookup 命令怎么用 DNS
域名系统（DNS）是 Internet 的电话簿。人们通过域名（例如 nytimes.com 或 espn.com）在线访问信息。Web 浏览器通过 Internet 协议（IP）地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器可以加载 Internet 资源。</description>
			<content type="html"><![CDATA[<h4 id="-url-">一. URL 有哪几部分？</h4>
<p>URL 包括 &ldquo;协议+域名或 IP+端口号+路径+查询字符串+锚点&rdquo;
<img src="/images/url.gif" alt="URL"></p>
<p><strong>http：//或 https：//</strong></p>
<p>&ldquo;http&quot;代表超文本传输 ​​ 协议。让浏览器知道它将使用哪种协议来访问 domain 中指定的信息。“ https”协议是“超文本传输 ​​ 协议安全”的缩写，表示通过 HTTP 传输的信息已加密且安全。在 http 或 https 之后是冒号（：）和两个正斜杠（//），用于将协议与 URL 的其余部分分隔开。</p>
<p><strong>www</strong></p>
<p>接下来，“ www”代表万维网，用于区分内容。URL 的这一部分不是必需的，可以省去很多次。例如，键入“ <a href="http://computerhope.com">http://computerhope.com</a> ”仍然可以将您带到 Computer Hope 网站。地址的这一部分也可以代替重要的子页面，称为 subdomain。</p>
<p><strong>computerhope.com</strong></p>
<p>接下来，“ computerhope.com”是网站的域名。域的最后一部分称为域后缀，即 TLD。它用于标识网站的类型或位置。例如，“。com”是商业名称的缩写，“。org”是组织的缩写，“。co.uk”是英国。还有许多其他域后缀可用。要获取域名，您可以通过域名注册商注册名称。</p>
<p><strong>/jargon/u/</strong>
接下来的“行话”和上述网址的“U”形部分是目录在网页所在的服务器上。在此示例中，网页有两个目录，因此，如果您尝试在服务器上查找文件，则该文件将位于/public_html/jargon/u 目录中。对于大多数服务器，public_html 目录是包含 HTML 文件的默认目录。</p>
<p><strong>url.htm</strong></p>
<p>最后，url.htm 是您正在查看的域上的实际网页。尾随的.htm 是网页的文件扩展名，指示该文件是 HTML 文件。Internet 上的其他常见文件扩展名包括.html，.php，.asp，.cgi，.xml，.jpg 和.gif。这些文件扩展名中的每一个都执行不同的功能，就像计算机上所有不同类型的文件一样。</p>
<h4 id="-dns-nslookup-">二. DNS 的作用是什么，nslookup 命令怎么用</h4>
<p><strong>DNS</strong></p>
<p>域名系统（DNS）是 Internet 的电话簿。人们通过域名（例如 nytimes.com 或 espn.com）在线访问信息。Web 浏览器通过 Internet 协议（IP）地址进行交互。DNS 将域名转换为 IP 地址，以便浏览器可以加载 Internet 资源。</p>
<p>连接到 Internet 的每个设备都有一个唯一的 IP 地址，其他计算机可使用该 IP 地址查找该设备。DNS 服务器消除了人们存储 IP 地址（例如 192.168.1.1（在 IPv4 中））或更复杂的较新的字母数字 IP 地址（例如 2400：cb00：2048：1 :: c629：d7a2（在 IPv6 中））的需要。</p>
<p><strong>nslookup 命令</strong></p>
<p>Nslookup –它是一个功能强大的网络管理命令行工具，用于查询域名系统（DNS）以获取域名或 IP 地址，映射或其他任何特定的 DNS 记录。</p>
<p><strong>主要用于:</strong></p>
<ul>
<li>查找主机的 IP 地址。</li>
<li>查找 IP 地址的域名。</li>
<li>查找域的邮件服务器。
<img src="/images/nslookup%E5%91%BD%E4%BB%A4.png" alt="URL"></li>
</ul>
<h4 id="-ip-ping-">三. IP 的作用是什么，ping 命令怎么用</h4>
<p><strong>IP (Internet Protocol)</strong> 地址是网络硬件的地址。它有助于将计算机连接到网络上以及全球的其他设备。IP 地址由数字或字符组成。
<strong>Ping 命令</strong>
<img src="/images/ping.png" alt="URL"></p>
<p><strong>ping</strong>命令通常用作验证计算机通过网络与另一台计算机或网络设备通信的简单方法。</p>
<h4 id="-">四. 域名是什么，分别哪几类域名</h4>
<ol>
<li>域名可以说是一个 IP 地址的代称，目的是为了便于记忆后者。(qq.com,baidu.com 就是域名)</li>
<li>域名主要有三类：
<ul>
<li>一级域名</li>
<li>二级域名</li>
<li>三级域名</li>
</ul>
</li>
</ol>
<p>例如：</p>
<p><a href="http://www.xiedaimala.com">www.xiedaimala.com</a> 是二级域名(俗称一级域名)</p>
<p>xiedaimala.com 是三级域名(俗称二级域名)</p>
]]></content>
		</item>
		
		<item>
			<title>HTML5常用标签</title>
			<link>https://wuchuan.monster/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</link>
			<pubDate>Sat, 28 Dec 2019 10:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/html%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</guid>
			<description>一. a 标签的用法   他的作用：
 跳转外部页面 跳转内部锚点 跳转到邮箱或电话等    他的属于有:
href:
 取值：  网址例如：  https://qq.com http://qq.com //qq.com(推荐这种)   路径例如：  /a/b/c a/b/c index.html 或者 ./index.html   伪协议：  javascript：代码； maito:邮箱 tel:手机号   id：  href=#xxx；      target:
 取值： 内置名字：  _blank _top _parent _self   程序员命名：  window 的 name iframe 的 name    download:</description>
			<content type="html"><![CDATA[<h3 id="-a-">一. a 标签的用法</h3>
<ol>
<li>
<p>他的作用：</p>
<ul>
<li>跳转外部页面</li>
<li>跳转内部锚点</li>
<li>跳转到邮箱或电话等</li>
</ul>
</li>
<li>
<p>他的属于有:</p>
<p>href:</p>
<ul>
<li>取值：
<ul>
<li>网址例如：
<ul>
<li><a href="https://qq.com">https://qq.com</a></li>
<li><a href="http://qq.com">http://qq.com</a></li>
<li>//qq.com(推荐这种)</li>
</ul>
</li>
<li>路径例如：
<ul>
<li>/a/b/c</li>
<li>a/b/c</li>
<li>index.html 或者 ./index.html</li>
</ul>
</li>
<li>伪协议：
<ul>
<li>javascript：代码；</li>
<li>maito:邮箱</li>
<li>tel:手机号</li>
</ul>
</li>
<li>id：
<ul>
<li>href=#xxx；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>target:</p>
<ul>
<li>取值：</li>
<li>内置名字：
<ul>
<li>_blank</li>
<li>_top</li>
<li>_parent</li>
<li>_self</li>
</ul>
</li>
<li>程序员命名：
<ul>
<li>window 的 name</li>
<li>iframe 的 name</li>
</ul>
</li>
</ul>
<p>download:</p>
<p>作用：</p>
<ul>
<li>
<p>不是打开页面，而是下载页面</p>
</li>
<li>
<p>问题：</p>
</li>
<li>
<p>不是所有浏览器都支持，尤其是手机浏览器可能不支持</p>
</li>
</ul>
<p>rel = noopener:</p>
<p>作用：</p>
<ul>
<li>是否新开一个页面</li>
</ul>
</li>
</ol>
<h3 id="-img-">二. img 标签的用法:</h3>
<ol>
<li>
<p>他的作用：</p>
<ul>
<li>发出 get 请求，展示一张图片</li>
</ul>
</li>
<li>
<p>他的属于有:</p>
<ul>
<li>alt:属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它难以置信地有用——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。</li>
</ul>
<ul>
<li>
<p>height:图片的高度</p>
</li>
<li>
<p>width:图片的宽度</p>
</li>
<li>
<p>src:属性是必须的，它包含了你想嵌入的图片的文件路径</p>
</li>
</ul>
</li>
<li>
<p>支持事件:</p>
<ul>
<li>onload(加载)/onerror(加载失败)</li>
</ul>
</li>
<li>
<p>响应式:</p>
<ul>
<li>max-width:100%(可以自适应屏幕宽度)</li>
</ul>
</li>
<li>
<p>他是可替换元素</p>
</li>
</ol>
<h3 id="-table-">三. table 标签的用法:</h3>
<ol>
<li>
<p>相关的标签:</p>
<ul>
<li>table</li>
<li>thead</li>
<li>tbody</li>
<li>tfoot</li>
<li>tr</li>
<li>td</li>
<li>th</li>
</ul>
</li>
</ol>
<p>建立表格示例：</p>
<pre><code class="language-html5" data-lang="html5">&lt;table&gt;
    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt;&lt;/th&gt;
            &lt;th&gt;&lt;/th&gt;
        &lt;/tr&gt;
    &lt;th&gt;
    &lt;/thead&gt;

    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;

    &lt;tfoot&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tfoot&gt;
&lt;/table&gt;  //table必须与这几个元素搭配使用。
</code></pre><ol>
<li>相关的样式：</li>
</ol>
<p><strong>table-layout</strong>：CSS 属性定义了用于布局表格单元格，行和列的算法。</p>
<p>table-layout 取值：</p>
<ul>
<li>auto(默认值):大多数浏览器采用自动表格布局算法对表格布局。表格及单元格的宽度取决于其包含的内容。</li>
</ul>
<ul>
<li>fixed:表格和列的宽度通过表格的宽度来设置，某一列的宽度仅由该列首行的单元格决定。在当前列中，该单元格所在行之后的行并不会影响整个列宽。</li>
</ul>
<p><strong>border-collapse</strong>:是用来决定表格的边框是分开的还是合并的。在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。</p>
<p>border-collapse 取值：</p>
<ul>
<li>collapse:合并（collapsed ）模式下，表格中相邻单元格共享边框。在这种模式下，CSS 属性 border-style 的值 inset 表现为槽，值 outset 表现为脊。</li>
</ul>
<ul>
<li>separate:分隔（separated）模式是 HTML 表格的传统模式。相邻单元格都拥有不同的边框。边框之间的距离是通过 CSS 属性 border-spacing 来确定的。</li>
</ul>
<p><strong>border-sapcing</strong>:属性指定相邻单元格边框之间的距离,初始值 &ldquo;0&rdquo;.</p>
<h3 id="-">四. 个人感想:</h3>
<ol>
<li>HTML5 标签和属性一定要多用</li>
<li>不懂的标签和属性 MDN 上查找</li>
<li>标签要理解记忆，死记容易忘记</li>
<li>前端工程师最大的忌讳是图片在网页上变形</li>
<li>手机浏览<!-- raw HTML omitted --></li>
</ol>
]]></content>
		</item>
		
		<item>
			<title>HTML入门笔记1</title>
			<link>https://wuchuan.monster/posts/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</link>
			<pubDate>Sat, 28 Dec 2019 09:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/html%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B01/</guid>
			<description>一. HTML 是英国的李爵士发明的，他在 2017 年获得图灵奖； 二. HTML 起手式是 Emmet+! 三. 常用的表章节的标签有：  表示标题 h1 ~ h6 章节 section 文章 article 段落 p 头部 header 脚步 footer 主要内容 main 旁支内容 aside 划分 div  四. HTML 全局属性有：  class 它允许 CSS 和 Javascript 通过类选择器 (class selectors) 或 DOM 方(document.getElementsByClassName)来选择和访问特定的元素。 contenteditable 是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。 hidden 是一个布尔属性，表示一个元素尚未或者不再相关。 id 定义了一个全文档唯一的标识符 (ID)。它用于在链接（使用片段）、脚本和样式（通过 CSS）中辨识元素。 style 包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是 CSS 的格式。 tabindex 指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用 Tab 键，因此得名）。 title 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。  五. 常用内容标签有:   ol + li 表示有序列表</description>
			<content type="html"><![CDATA[<h3 id="-html--2017-">一. HTML 是英国的李爵士发明的，他在 2017 年获得图灵奖；</h3>
<h3 id="-html--emmet">二. HTML 起手式是 Emmet+!</h3>
<h3 id="-">三. 常用的表章节的标签有：</h3>
<ol>
<li>表示标题 h1 ~ h6</li>
<li>章节 section</li>
<li>文章 article</li>
<li>段落 p</li>
<li>头部 header</li>
<li>脚步 footer</li>
<li>主要内容 main</li>
<li>旁支内容 aside</li>
<li>划分 div</li>
</ol>
<h3 id="-html-">四. HTML 全局属性有：</h3>
<ol>
<li><strong>class</strong> 它允许 CSS 和 Javascript 通过类选择器 (class selectors) 或 DOM 方(document.getElementsByClassName)来选择和访问特定的元素。</li>
<li><strong>contenteditable</strong> 是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。</li>
<li><strong>hidden</strong> 是一个布尔属性，表示一个元素尚未或者不再相关。</li>
<li><strong>id</strong> 定义了一个全文档唯一的标识符 (ID)。它用于在链接（使用片段）、脚本和样式（通过 CSS）中辨识元素。</li>
<li><strong>style</strong> 包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是 CSS 的格式。</li>
<li><strong>tabindex</strong> 指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用 Tab 键，因此得名）。</li>
<li><strong>title</strong> 定义文档的标题，显示在浏览器的标题栏或标签页上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。</li>
</ol>
<h3 id="--1">五. 常用内容标签有:</h3>
<ol>
<li>
<p><strong>ol + li</strong> 表示有序列表</p>
</li>
<li>
<p><strong>ul + li</strong> 表示无序列表</p>
<p>补充：ol 和 ul 必须和 li 搭配使用</p>
</li>
<li>
<p>dl + dt + dd 定义列表</p>
</li>
</ol>
<p>补充：dt 和 dd 必须和 ll 搭配使用,dl 主要用于定义清单列表</p>
<ol start="4">
<li><strong>pre</strong> 元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <!-- raw HTML omitted --> 开始标签后的换行符也会被省略)</li>
<li><strong>hr</strong> 表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。在 HTML 的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。</li>
<li><strong>br</strong> 在文本中生成一个换行（回车）符号。此元素在写诗和地址时很有用，这些地方的换行都非常重要。</li>
<li><strong>a</strong> 可以创建通向其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。</li>
<li><strong>em</strong> 标记出需要用户着重阅读的内容， <!-- raw HTML omitted --> 元素是可以嵌套的，嵌套层次越深，则其包含的内容被认定为越需要着重阅读。</li>
<li><strong>strong</strong> 表示文本十分重要，一般用粗体显示。</li>
<li><strong>code</strong> 呈现一段计算机代码. 默认情况下, 它以浏览器的默认等宽字体显示</li>
<li><strong>q</strong> 表示一个封闭的并且是短的行内引用的文本. 这个标签是用来引用短的文本，所以请不要引入换行符; 对于长的文本的引用请使用 blockquote 替代.</li>
<li><strong>blkockquote</strong> 代表其中的文字是引用内容。通常在渲染时，这部分的内容会有一定的缩进（注 中说明了如何更改）。若引文来源于网络，则可以将原内容的出处 URL 地址设置到 cite 特性上，若要以文本的形式告知读者引文的出处时，可以通过 <!-- raw HTML omitted --> 元素。</li>
</ol>
<h3 id="-html5-----html5--mdn">六. HTML5 不懂的标签 请搜索 标签名 + HTML5 + MDN</h3>
]]></content>
		</item>
		
		<item>
			<title>如何使用hugo写博客</title>
			<link>https://wuchuan.monster/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E5%86%99%E5%8D%9A%E5%AE%A2/</link>
			<pubDate>Thu, 26 Dec 2019 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E5%86%99%E5%8D%9A%E5%AE%A2/</guid>
			<description>环境搭建   你需要 FQ
  安装 VSCode
  安装 GIT
  安装 cmder
  安装 hugo
  hugo 官方安装教程
  注意检查本地 PATH 路径是否有 hugo 启动路径
  cmder 中输入下列代码检查是否安装成功
   hugo version hugo 快速开始   hugo 官网
  点击 Quick Start
  按官方教程一步步做
  注意事项：   步骤 2 quickstart 文件夹命名更改格式: 你的 github 用户名.github.io-xxx
  步骤 3 可以更改博客主题，新手不建议更改</description>
			<content type="html"><![CDATA[<h3 id="heading">环境搭建</h3>
<ol>
<li>
<p>你需要 FQ</p>
</li>
<li>
<p>安装 VSCode</p>
</li>
<li>
<p>安装 GIT</p>
</li>
<li>
<p>安装 cmder</p>
</li>
<li>
<p>安装 hugo</p>
</li>
<li>
<p><a href="https://gohugo.io/getting-started/installing">hugo 官方安装教程</a></p>
</li>
<li>
<p>注意检查本地 PATH 路径是否有 hugo 启动路径</p>
</li>
<li>
<p>cmder 中输入下列代码检查是否安装成功</p>
</li>
</ol>
<pre><code>  hugo version
</code></pre><h3 id="hugo-">hugo 快速开始</h3>
<ol>
<li>
<p><a href="https://gohugo.io">hugo 官网</a></p>
</li>
<li>
<p>点击 Quick Start</p>
</li>
<li>
<p>按官方教程一步步做</p>
</li>
</ol>
<h4 id="heading-1">注意事项：</h4>
<ol>
<li>
<p>步骤 2 quickstart 文件夹命名更改格式: 你的 github 用户名.github.io-xxx</p>
</li>
<li>
<p>步骤 3 可以更改博客主题，新手不建议更改</p>
</li>
</ol>
<p>hugo 操作完毕。</p>
<h3 id="-github">上传至 GitHub**</h3>
<ol>
<li>
<p>到你创建博客文件夹的根目录创建一个文件,命名为.gitignore,在里面输入/public/</p>
</li>
<li>
<p>进入 public 文件夹,输入下列代码</p>
</li>
</ol>
<pre><code>git init

git add.

git commit -v
</code></pre><ol start="3">
<li>进入 githua 创建一个新的仓库，命名规则: 用户名.github.io</li>
<li>复制 github 里面的俩行代码即可部署完成</li>
</ol>
<pre><code>git remote add origin
git push -u origin master
</code></pre><ol start="5">
<li>进入 setting 查看部署完成链接</li>
</ol>
<h3 id="github-">Github 备份你的博客代码</h3>
<ol>
<li>github 创建一个新的仓库</li>
<li>复制那俩行代码即可</li>
</ol>
<h3 id="github--1">Github 更新你的代码</h3>
<pre><code>git status
git add .
git commit -v
git pull
git push origin master
</code></pre>]]></content>
		</item>
		
		<item>
			<title>小结</title>
			<link>https://wuchuan.monster/posts/%E5%B0%8F%E7%BB%93/</link>
			<pubDate>Thu, 26 Dec 2019 13:12:19 +0800</pubDate>
			
			<guid>https://wuchuan.monster/posts/%E5%B0%8F%E7%BB%93/</guid>
			<description>什么是闭包？闭包的用途是什么？闭包的缺点是什么？ MDN 对闭包的定义为：
闭包是指那些能够访问自由变量的函数。
那什么是自由变量呢？
自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。
由此，我们可以看出闭包共有两部分组成：
闭包 = 函数 + 函数能够访问的自由变量
举个例子：
var a = 1;function foo() {console.log(a);}foo();用途:
  希望一个变量长期保存内存中；
  避免全局变量污染；
  私有成员的存在。
  闭包的缺点：
  常驻内存，增加内存使用量；
  使用不当造成内存泄漏。
  call、apply、bind 的用法分别是什么？ call 函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。
var obj = {};var f = function () {return this;};f() === window // truef.call(obj) === obj // truecall方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</description>
			<content type="html"><![CDATA[<h3 id="heading">什么是闭包？闭包的用途是什么？闭包的缺点是什么？</h3>
<p>MDN 对闭包的定义为：</p>
<p>闭包是指那些能够访问自由变量的函数。</p>
<p>那什么是自由变量呢？</p>
<p>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。</p>
<p>由此，我们可以看出闭包共有两部分组成：</p>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
<p>举个例子：</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><p>用途:</p>
<ol>
<li>
<p>希望一个变量长期保存内存中；</p>
</li>
<li>
<p>避免全局变量污染；</p>
</li>
<li>
<p>私有成员的存在。</p>
</li>
</ol>
<p>闭包的缺点：</p>
<ol>
<li>
<p>常驻内存，增加内存使用量；</p>
</li>
<li>
<p>使用不当造成内存泄漏。</p>
</li>
</ol>
<h3 id="callapplybind-">call、apply、bind 的用法分别是什么？</h3>
<h4 id="call">call</h4>
<p>函数实例的call方法，可以指定函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="p">}</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>

<span class="nx">f</span><span class="p">(</span><span class="p">)</span> <span class="o">===</span> <span class="nb">window</span> <span class="c1">// true
</span><span class="c1"></span><span class="nx">f</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">===</span> <span class="nx">obj</span> <span class="c1">// true
</span></code></pre></div><p>call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<h4 id="apply">apply</h4>
<p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="nx">func</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">thisValue</span><span class="p">,</span> <span class="p">[</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">,</span> <span class="p">...</span><span class="p">]</span><span class="p">)</span>
</code></pre></div><p>apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，必须以数组形式添加。</p>
<h4 id="bind">bind</h4>
<p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。如果bind方法的第一个参数是null或undefined，等于将this绑定到全局对象，函数运行时this指向顶层对象（浏览器为window）。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">counter</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">count</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nx">inc</span><span class="o">:</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">count</span><span class="o">:</span> <span class="mi">100</span>
<span class="p">}</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">func</span> <span class="o">=</span> <span class="nx">counter</span><span class="p">.</span><span class="nx">inc</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span><span class="p">;</span>
<span class="nx">func</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="nx">obj</span><span class="p">.</span><span class="nx">count</span> <span class="c1">// 101
</span></code></pre></div><p>上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。</p>
<h3 id="-10--http-">请说出至少 10 个 HTTP 状态码，并描述各状态码的意义。</h3>
<p>例如：状态码 200 表示响应成功。</p>
<h4 id="2xx">2xx成功</h4>
<p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<h4 id="200-ok">200 OK</h4>
<p>请求已成功，请求所希望的响应头或数据体将随此响应返回。实际的响应将取决于所使用的请求方法。在GET请求中，响应将包含与请求的资源相对应的实体。在POST请求中，响应将包含描述或操作结果的实体。</p>
<h4 id="404-not-found">404 Not Found</h4>
<p>请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<h4 id="505-http-version-not-supported">505 HTTP Version Not Supported</h4>
<p>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>
<h4 id="204-no-content">204 No Content</h4>
<p>服务器成功处理了请求，没有返回任何内容。</p>
<h4 id="205-reset-content">205 Reset Content</h4>
<p>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。</p>
<h4 id="3xx">3xx重定向</h4>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p>
<h4 id="4xx">4xx客户端错误</h4>
<p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<h4 id="5xx">5xx服务器错误</h4>
<p>表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。</p>
<p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。（例如，网络服务API的新功能）</p>
<h4 id="504-gateway-timeout">504 Gateway Timeout</h4>
<p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。
注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</p>
<h4 id="418-im-a-teapotrfc-2324">418 I'm a teapot（RFC 2324）</h4>
<p>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324超文本咖啡壶控制协议'中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。这个HTTP状态码在某些网站（包括Google.com）与项目（如Node.js、ASP.NET和Go语言）中用作彩蛋。</p>
<h4 id="402-payment-required">402 Payment Required</h4>
<p>该状态码是为了将来可能的需求而预留的。该状态码最初的意图可能被用作某种形式的数字现金或在线支付方案的一部分，但几乎没有哪家服务商使用，而且这个状态码通常不被使用。如果特定开发人员已超过请求的每日限制，Google Developers API会使用此状态码。</p>
<h4 id="205-reset-content-1">205 Reset Content</h4>
<p>服务器成功处理了请求，但没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图。</p>
<h3 id="heading-1">著名面试题：</h3>
<p>如何实现数组去重？
假设有数组 array = [1,5,2,3,4,2,3,1,3,4]
你要写一个函数 unique，使得
unique(array) 的值为 [1,5,2,3,4]
也就是把重复的值都去掉，只保留不重复的值。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">unique</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="p">[</span><span class="p">]</span><span class="p">;</span>  
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">===</span> <span class="k">this</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">j</span> <span class="o">=</span> <span class="o">++</span><span class="nx">i</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">newArray</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">newArray</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">unique</span><span class="p">(</span><span class="p">)</span><span class="c1">//[5, 2, 1, 3, 4]
</span><span class="c1"></span>
<span class="c1">//map
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">unique</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Map</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="p">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">tmp</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="p">;</span>
  <span class="p">}</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">unique</span><span class="p">(</span><span class="p">)</span><span class="c1">//[1, 5, 2, 3, 4]
</span><span class="c1"></span>
<span class="c1">//set
</span><span class="c1"></span><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span>  <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">unique</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Set</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="p">;</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">from</span><span class="p">(</span><span class="nx">set</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">unique</span><span class="p">(</span><span class="p">)</span><span class="c1">//[1, 5, 2, 3, 4]
</span></code></pre></div><p>map方法运算时间和性能比较好，set方法比较简单，易懂。</p>
<h3 id="dom-">DOM 事件相关</h3>
<pre><code>* 什么是事件委托？


  事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
  原理：事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。



* 怎么阻止默认动作？
  DOM中提供preventDefault()方法来取消事件默认行为，但是只有当cancelable属性设置为true的事件，才可以使用preventDefault()来取消事件默认行为，使用event对象在事件函数中调用就行
</code></pre>
<p>IE中提供的是returnValue属性，默认为true，当它设置为false时，就是取消事件默认行为，也是用event对象在事件函数中调用</p>
<p>jQuery中提供了preventDefault()方法来阻止元素的默认行为，只需要用event对象来调用就好，即event.preventDefault()</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">stopDefault</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="p">{</span>  
   <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">)</span> <span class="p">{</span>  
      <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
      <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">.</span><span class="nx">returnValue</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>  
   <span class="p">}</span>  
   <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>  
  <span class="p">}</span><span class="p">;</span>  
</code></pre></div><pre><code>* 怎么阻止事件冒泡？
DOM中提供stopPropagation()方法，但IE不支持，使用event对象在事件函数中调用就行。
</code></pre>
<p>IE中提供的是，cancelBubble属性，默认为false，当它设置为true时，就是阻止事件冒泡，也是用event对象在事件函数中调用</p>
<p>jQuery中提供了stopPropagation()方法来停止事件冒泡，当需要时，只需用用event对象来调用就行，即event.stopPropagation()。
例子:</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">stopBubble</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>  
 <span class="k">if</span><span class="p">(</span><span class="nx">e</span> <span class="o">&amp;&amp;</span> <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">)</span><span class="p">{</span>  
      <span class="nx">e</span><span class="p">.</span><span class="nx">stopPropagation</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>  
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
    <span class="nb">window</span><span class="p">.</span><span class="nx">event</span><span class="p">.</span><span class="nx">cancelBubble</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>  
  <span class="p">}</span>  
<span class="p">}</span><span class="p">;</span>  
</code></pre></div><h3 id="-js-">你如何理解 JS 的继承？</h3>
<pre><code>* 基于原型的继承
  构造函数、原型和实例之间的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。
</code></pre>
<p>继承的本质就是复制，即重写原型对象，代之以一个新类型的实例。</p>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">SuperType</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">property</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">SuperType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSuperValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">property</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">SubType</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 这里是关键，创建SuperType的实例，并将该实例赋值给SubType.prototype
</span><span class="c1"></span><span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SuperType</span><span class="p">(</span><span class="p">)</span><span class="p">;</span> 

<span class="nx">SubType</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getSubValue</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">subproperty</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">SubType</span><span class="p">(</span><span class="p">)</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">instance</span><span class="p">.</span><span class="nx">getSuperValue</span><span class="p">(</span><span class="p">)</span><span class="p">)</span><span class="p">;</span> <span class="c1">// true
</span></code></pre></div><pre><code>* 基于 class 的继承
Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。
extends关键字主要用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。其中constructor表示构造函数，一个类中只能有一个构造函数，有多个会报出SyntaxError错误,如果没有显式指定构造方法，则会添加默认的 constructor方法，使用例子如下。
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">class</span> <span class="nx">Rectangle</span> <span class="p">{</span>
    <span class="c1">// constructor
</span><span class="c1"></span>    <span class="nx">constructor</span><span class="p">(</span><span class="nx">height</span><span class="p">,</span> <span class="nx">width</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">=</span> <span class="nx">height</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">width</span> <span class="o">=</span> <span class="nx">width</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="c1">// Getter
</span><span class="c1"></span>    <span class="nx">get</span> <span class="nx">area</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">calcArea</span><span class="p">(</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="c1">// Method
</span><span class="c1"></span>    <span class="nx">calcArea</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">rectangle</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Rectangle</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rectangle</span><span class="p">.</span><span class="nx">area</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// 输出 200
</span><span class="c1"></span>
<span class="c1">// 继承
</span><span class="c1"></span><span class="kr">class</span> <span class="nx">Square</span> <span class="kr">extends</span> <span class="nx">Rectangle</span> <span class="p">{</span>

  <span class="nx">constructor</span><span class="p">(</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">super</span><span class="p">(</span><span class="nx">length</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span><span class="p">;</span>
    
    <span class="c1">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。
</span><span class="c1"></span>    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">&#39;Square&#39;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">get</span> <span class="nx">area</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">height</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">width</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">square</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Square</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">square</span><span class="p">.</span><span class="nx">area</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// 输出 100
</span></code></pre></div><p>没有“继承”机制的话， JavaScript 中的类就只是一个空架子。</p>
<h3 id="promise">Promise</h3>
<pre><code>* Promise 的用途
    * Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。

* 如何创建一个 new Promise
    * return new Promise((resolve,reject)=&gt;{})

* 如何使用 Promise.prototype.then
    * then() 方法返回一个 Promise。它最多需要有两个参数：Promise 的成功和失败情况的回调函数。
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;Success!&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="nx">promise1</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="p">;</span>
  <span class="c1">// expected output: &#34;Success!&#34;
</span><span class="c1"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span>
</code></pre></div><pre><code>* 如何使用 Promise.all
    * Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败原因的是第一个失败 promise 的结果。
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">promise3</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;foo&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="p">[</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">,</span> <span class="nx">promise3</span><span class="p">]</span><span class="p">)</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">values</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// expected output: Array [3, 42, &#34;foo&#34;]
</span></code></pre></div><pre><code>* 如何使用 Promise.race
    Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kr">const</span> <span class="nx">promise1</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="s1">&#39;one&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">promise2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s1">&#39;two&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">)</span><span class="p">;</span>

<span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">(</span><span class="p">[</span><span class="nx">promise1</span><span class="p">,</span> <span class="nx">promise2</span><span class="p">]</span><span class="p">)</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="p">;</span>
  <span class="c1">// Both resolve, but promise2 is faster
</span><span class="c1"></span><span class="p">}</span><span class="p">)</span><span class="p">;</span>
<span class="c1">// expected output: &#34;two&#34;
</span></code></pre></div><h3 id="heading-2">说说跨域</h3>
<pre><code>* 什么是同源
    如果俩个url协议相同、域名相同、端口相同,那么这俩个url就是同源的，不同源的页面之间，不准互相访问数据。同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

* 什么是跨域
    跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 施加的安全限制。

    

* JSONP 跨域
    我们在跨域的时候由于当前浏览器不支持CORS或者因为某些条件不支持CORS，我们必须使用另外一种方式来跨域，于是我们就请求一个JS文件，这个JS文件会执行一个回调，回调里面就有我们的数据；
    回调的名字是什么？
    回调名字是随机生成的，随机数，我们把这个名字已callback的参数传给后台，后台会把这个函数再次返回给我们并执行。
    优点：
    1. 兼容IE
    2. 可以跨域
    缺点：
    1. 由于它是script标签，所以他读不到AJAX那么精确的状态是什么，拿不到状态码和HEADER他只知道成功和失败
    2. 由于是script标签，所以他只能发GET请求；JSONP不支持POST
</code></pre>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">addScriptTag</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;script&#39;</span><span class="p">)</span><span class="p">;</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="s2">&#34;type&#34;</span><span class="p">,</span><span class="s2">&#34;text/javascript&#34;</span><span class="p">)</span><span class="p">;</span>
  <span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">src</span><span class="p">;</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">addScriptTag</span><span class="p">(</span><span class="s1">&#39;http://example.com/ip?callback=foo&#39;</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;Your public IP address is: &#39;</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">ip</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span><span class="p">;</span>
</code></pre></div><p>上面代码通过动态添加<!-- raw HTML omitted -->元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。</p>
<pre><code>* CORS 跨域
    跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。
</code></pre>
<p>比如，站点 <a href="http://domain-a.com">http://domain-a.com</a> 的某 HTML 页面通过 <!-- raw HTML omitted --> 的 src 请求 <a href="http://domain-b.com/image.jpg">http://domain-b.com/image.jpg</a>。网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。
出于安全原因，浏览器限制从脚本内发起的跨源HTTP请求。 例如，XMLHttpRequest和Fetch API遵循同源策略。 这意味着使用这些API的Web应用程序只能从加载应用程序的同一个域请求HTTP资源，除非响应报文包含了正确CORS响应头。</p>
<p>（译者注：这段描述不准确，并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。）
跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。现代浏览器支持在 API 容器中（例如 XMLHttpRequest 或 Fetch ）使用 CORS，以降低跨域 HTTP 请求所带来的风险。
语法：
Access-Control-Allow-Origin: <!-- raw HTML omitted --> | *</p>
<h3 id="heading-3">数组排序</h3>
<div class="highlight"><pre class="chroma"><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">array</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">minIndex</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">min</span><span class="p">(</span>
    <span class="p">[</span><span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="p">,</span> <span class="nx">min</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="p">)</span><span class="p">]</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">numbers</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">sort</span> <span class="o">=</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">minIndex</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span>
    <span class="nx">numbers</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="nx">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">min</span><span class="p">]</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">sort</span><span class="p">(</span><span class="nx">numbers</span><span class="p">)</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">?</span> <span class="nx">numbers</span> <span class="o">:</span>
      <span class="nx">numbers</span><span class="p">.</span><span class="nx">reverse</span><span class="p">(</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">array</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span><span class="p">)</span> <span class="c1">//[1, 2, 3, 4, 5, 5, 8, 9]
</span></code></pre></div><h3 id="heading-4">前端理解</h3>
<p>刚接触前端的时候，我以为网页就是HTML和CSS，学了一段时间之后发现，单纯的HTML和CSS无法与人直接打交道，必须学习JavaScript脚本语言，我的第一门编程语言。</p>
<p>JavaScript又引出了原来所不知道的知识，比如说:</p>
<ul>
<li>HTTP</li>
<li>浏览器性能</li>
<li>与用户的交互(AJAX)</li>
<li>安全相关(跨域，数据安全，axios)</li>
<li>计算机的底层</li>
<li>浏览器的底层(JS引擎)</li>
<li>URL</li>
<li>算法</li>
</ul>
<p>有了JS前端才能称之为程序员，学好JS就必须了解底层，这样才能知道如何优化性能，提高内存使用率；同时JS是一门高效的语言，因为他是单线程。
甚至基于JS还发展出了Nodejs,可以处理一些简单的后端开发。
网页上也能开发应用了。
因为有了交互，前端可以做的很复杂，从而引出了一些前端必学的库和框架，jQuery、Vue、React、Angular等。
基于Flutter还可以开发手机应用。</p>
<h3 id="heading-5">总结：</h3>
<p>前端的技术更新速度非常快，不进则退，必须不断的学习新的技术。学习一些经典的库和框架思维和写法。基础很重要，也就是底层，可以决定我们以后是否可以造出好的轮子。</p>
]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://wuchuan.monster/posts/js/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://wuchuan.monster/posts/js/</guid>
			<description>new命令的原理 使用new命令时，它后面的函数依次执行下面的步骤。
创建一个空对象，作为将要返回的对象实例。 将这个空对象的原型，指向构造函数的prototype属性。 将这个空对象赋值给函数内部的this关键字。 开始执行构造函数内部的代码。
重要1:JS公式 第一个重要知识：JS公式 对象.__proto__===其构造函数.prototype JS唯一公式，如果不会就套公式
重要2:根公理 Object.prototype是所有对象的(直接或间接)原型 加了一个直接或间接，所谓公理就是规定好的
重要3：函数公理 所有函数都是由Function构造的 任何函数.proto === Function.prototype 任意函数有Object/Array/Function
除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。
Object实例对象的方法，主要有以下六个。
Object.prototype.valueOf()：返回当前对象对应的值。 Object.prototype.toString()：返回当前对象对应的字符串形式。 Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。 Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。 Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。
JSON 格式（JavaScript Object Notation 的缩写）
this就是属性或方法“当前”所在的对象 内部的this就会指向f运行时所在的对象（本例是顶层对象）。 现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。
this主要有以下几个使用场合。
（1）全局环境
全局环境使用this，它指的就是顶层对象window。
（2）构造函数
构造函数中的this，指的是实例对象。
（3）对象的方法
如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</description>
			<content type="html"><![CDATA[<p>new命令的原理
使用new命令时，它后面的函数依次执行下面的步骤。</p>
<p>创建一个空对象，作为将要返回的对象实例。
将这个空对象的原型，指向构造函数的prototype属性。
将这个空对象赋值给函数内部的this关键字。
开始执行构造函数内部的代码。</p>
<p>重要1:JS公式
第一个重要知识：JS公式
对象.__proto__===其构造函数.prototype
JS唯一公式，如果不会就套公式</p>
<p>重要2:根公理
Object.prototype是所有对象的(直接或间接)原型
加了一个直接或间接，所谓公理就是规定好的</p>
<p>重要3：函数公理
所有函数都是由Function构造的
任何函数.<strong>proto</strong> === Function.prototype
任意函数有Object/Array/Function</p>
<p>除了静态方法，还有不少方法定义在Object.prototype对象。它们称为实例方法，所有Object的实例对象都继承了这些方法。</p>
<p>Object实例对象的方法，主要有以下六个。</p>
<p>Object.prototype.valueOf()：返回当前对象对应的值。
Object.prototype.toString()：返回当前对象对应的字符串形式。
Object.prototype.toLocaleString()：返回当前对象对应的本地字符串形式。
Object.prototype.hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
Object.prototype.isPrototypeOf()：判断当前对象是否为另一个对象的原型。
Object.prototype.propertyIsEnumerable()：判断某个属性是否可枚举。</p>
<p>JSON 格式（JavaScript Object Notation 的缩写）</p>
<p>this就是属性或方法“当前”所在的对象
内部的this就会指向f运行时所在的对象（本例是顶层对象）。
现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，this就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<p>this主要有以下几个使用场合。</p>
<p>（1）全局环境</p>
<p>全局环境使用this，它指的就是顶层对象window。</p>
<p>（2）构造函数</p>
<p>构造函数中的this，指的是实例对象。</p>
<p>（3）对象的方法</p>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。</p>
]]></content>
		</item>
		
		<item>
			<title></title>
			<link>https://wuchuan.monster/posts/%E6%8E%92%E5%BA%8F/</link>
			<pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
			
			<guid>https://wuchuan.monster/posts/%E6%8E%92%E5%BA%8F/</guid>
			<description>let sort = (numbers) =&amp;gt; { if(numbers.length &amp;gt; 2){ let index = minIndex(numbers) let min = numbers[index] numbers.splice(index, 1) return [min].concat(sort(numbers)) }else{ return numbers[0]&amp;lt;numbers[1] ? numbers : numbers.reverse() } }
let minIndex = (numbers) =&amp;gt; let index = 0 for(let i=1; i&amp;lt;numbers.length; i++){ if(numbers[i] &amp;lt; numbers[index]){ index = i } } return index }
let sort = (numbers) =&amp;gt; { for(let i=0; i&amp;lt;???; i++){ let index = minIndex(numbers) // index 是当前最小数的下标 // index 对应的数应该放到 i 处 swap(numbers, index, i) // swap 还没实现 // index、i 都是 index 的意思，建议 i 改名 } }</description>
			<content type="html"><![CDATA[<p>let sort = (numbers) =&gt; {
if(numbers.length &gt; 2){
let index = minIndex(numbers)
let min = numbers[index]
numbers.splice(index, 1)
return [min].concat(sort(numbers))
}else{
return numbers[0]&lt;numbers[1] ? numbers :
numbers.reverse()
}
}</p>
<p>let minIndex = (numbers) =&gt;
let index = 0
for(let i=1; i&lt;numbers.length; i++){
if(numbers[i] &lt; numbers[index]){
index = i
}
}
return index
}</p>
<p>let sort = (numbers) =&gt; {
for(let i=0; i&lt;???; i++){
let index = minIndex(numbers)
// index 是当前最小数的下标
// index 对应的数应该放到 i 处
swap(numbers, index, i) // swap 还没实现
// index、i 都是 index 的意思，建议 i 改名
}
}</p>
<p>let swap = (array, i, j) =&gt; {
let temp = array[i]
array[i] = array[j]
array[j] = temp
}
swap(numbers, 1, 2)</p>
<p>// 选择排序最终代码</p>
<p>let sort = (numbers) =&gt; {
for(let i=0; i&lt; numbers.length -1; i++){
console.log(<code>----</code>) //这个log很精髓
console.log(<code>i: ${i}</code>)
let index = minIndex(numbers.slice(i))+ i
console.log(<code>index: ${index}</code>)
console.log(<code>min: ${numbers[index]}</code>)
if(index!==i){
swap(numbers, index, i)
console.log(<code>swap ${index}: ${i}</code>)
console.log(numbers)
}
}
return numbers
}</p>
<p>let swap = (array, i, j) =&gt; {
let temp = array[i]
array[i] = array[j]
array[j] = temp
}
let minIndex = (numbers) =&gt; {
let index = 0
for(let i=1; i&lt;numbers.length; i++){
if(numbers[i] &lt; numbers[index]){
index = i
}
}
return index
}</p>
<p>// 快速排序</p>
<p>let quickSort = arr =&gt; {
　　if (arr.length &lt;= 1) { return arr; }
　　let pivotIndex = Math.floor(arr.length / 2);
　　let pivot = arr.splice(pivotIndex, 1)[0];
　　let left = [];
　　let right = [];
　　for (let i = 0; i &lt; arr.length; i++){
　　　　if (arr[i] &lt; pivot) { left.push(arr[i])
　　　　} else { right.push(arr[i]) }
　　}
　　return quickSort(left).concat(
[pivot], quickSort(right) )
}</p>
<p>// 归并排序
let mergeSort = arr =&gt;{
let k = arr.length
if(k===1){return arr}
let left = arr.slice(0, Math.floor(k/2))
let right = arr.slice(Math.floor(k/2))
return merge(mergeSort(left), mergeSort(right))
}
let merge = (a, b) =&gt; {
if(a.length === 0) return b
if(b.length === 0) return a
return a[0] &gt; b[0] ?
[b[0]].concat(merge(a, b.slice(1))) :
[a[0]].concat(merge(a.slice(1), b))
}</p>
<p>// 计数排序
let countSort = arr =&gt;{
let hashTable = {}, max = 0, result = []
for(let i=0; i&lt;arr.length; i++){ // 遍历数组
if(!(arr[i] in hashTable)){ // 视频中这一行写错
hashTable[arr[i]] = 1
}else{
hashTable[arr[i]] += 1
}
if(arr[i] &gt; max) {max = arr[i]}
}
for(let j=0; j&lt;=max; j++){ // 遍历哈希表
if(j in hashTable){
for(let i = 0; i&lt;hashTable[j]; i++){
result.push(j)
}
}
}
return result
}</p>
]]></content>
		</item>
		
	</channel>
</rss>
